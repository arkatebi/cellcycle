#include<stdio.h>
#include<stdlib.h>
#include<math.h>
#include<time.h>
#include<stdbool.h>
#include<string.h>
#include "pcg_basic.h"
#include "pertParamSim.h"

const double ZERO=1.0e-10;

const size_t LINE_SIZE=300; 
const char CONFIG_FILE_DELIM[5]=":";

//SUBSET OF CONFIG PARAMETERS:
struct config_dict {
       int NUM_RANDOM_ICS;
       long double CONVERGENCE_PROXIMITY;
       double SAMEPOINT_PROXIMITY;
       int ITER_FOR_ODE;
       int ITER_FOR_RELAXATION;
       int ITER_FOR_LIMIT_CYCLE;
       double EULER_SIM_TIME;
       double EULER_SIM_TIME_LAST_ANN_STEP;
       double STARTING_NOISE_ANN;
       double STARTING_NOISE_CONSTANT;
       double NOISE_SCALING_FACTOR_ANN;
       double LIMIT_CYCLE_SIM_TIME;
       double EULER_SIM_STEP_SIZE;
       double LIMIT_CYCLE_SIM_STEP_SIZE;
       int MAX_STABLE_STATES;
       int MAX_LIMIT_CYCLES;
       int MAX_ALLOWED_PERIODS;
       int NO_OF_SAMPLED_PERIODS;
       int ALLOWED_ERROR_IN_PERIODS;
}; 

//DEFAULT VALUES:
struct config_dict sim_config={
       .NUM_RANDOM_ICS=1000, 
       .CONVERGENCE_PROXIMITY=1.0e-12,
       .SAMEPOINT_PROXIMITY=0.1,
       .ITER_FOR_ODE=200,
       .ITER_FOR_RELAXATION=10,
       .ITER_FOR_LIMIT_CYCLE=20,
       .EULER_SIM_TIME=10,
       .EULER_SIM_TIME_LAST_ANN_STEP=2000,
       .STARTING_NOISE_ANN=20,
       .STARTING_NOISE_CONSTANT=20,
       .NOISE_SCALING_FACTOR_ANN=0.95,
       .LIMIT_CYCLE_SIM_TIME=10,
       .EULER_SIM_STEP_SIZE=0.01,
       .LIMIT_CYCLE_SIM_STEP_SIZE=0.01,
       .MAX_STABLE_STATES=20,
       .MAX_LIMIT_CYCLES=10,
       .MAX_ALLOWED_PERIODS=100,
       .NO_OF_SAMPLED_PERIODS=3,
       .ALLOWED_ERROR_IN_PERIODS=3
};


/**********************************************************************/
void find_solutions(char *WORK_DIR, \
                    char *FNAME_STATES, \
                    char *FNAME_LIMITCYCLES, \
                    char *FNAME_SUMMARY, \
                    const int MODEL_NO,\
                    int NUM_NODES,int NUM_EDGES,\
                    int NUM_RANDOM_ICS,int ITER_FOR_ODE,\
                    double EULER_SIM_TIME,\
                    double EULER_STEP_SIZE,\
                    long double CONVERGENCE_PROXIMITY,\
                    double TRANS_RATE_FACTOR,\
                    const double *MPR_arrv,\
                    const double *DNR_arrv,\
                    const int *node_type_arrv,\
                    const int *edge_source_arrv,\
                    const int *edge_target_arrv,\
                    const int *edge_type_arrv,\
                    const double *TSH_arrv,\
                    const int *HCO_arrv,\
                    const double *FCH_arrv,\
                    double *EXP_dict_arrv) 
/*------------------------------------------------------------------
It carries out two main operations 
   (1) For each of the initial conditions, it estimates stable state 
       of the network (an n dimensional point) by repeatedly invoking 
       estimate_stable_expression function. 
   (2) After obtaining stable states for all initial conditions, 
       it clusters those stable state solutions by invoking 
       cluster_solutions function.

Definitions of the main data structures: 
   MPR_arrv: maximum production rates for each node
   DNR_arrv: degradation rates for each node  
   node_type_arrv: type for each node 

   edge_source_arrv: source id of each edge. Id of a source is the 
      corresponding index of the arrays MPR_arrv, DNR_arrv, and 
      node_type_arrv
   edge_target_arrv: target id of each edge
   edge_type_arrv: type of each edge 
   TSH_arrv: threshold of each edge
   HCO_arrv: hill coefficient for each edge
   FCH_arrv: fold change for each edge

   EXP_dict_arrv: stable expression level of all the nodes
--------------------------------------------------------------------*/
{
    //CONSTANTS:
    const int TOTAL_EULER_STEPS=(int) (EULER_SIM_TIME/EULER_STEP_SIZE);

    //VARIABLES:
    double *EXP_dict_arr=(double *) EXP_dict_arrv;
    double IC_arr[NUM_NODES]; //saves ICs generated by set_ICs()
    double exp_arr[NUM_NODES]; //saves exps from estimate_stable_expression()

    double minEXP_arr[NUM_NODES]; //minimum expression for all nodes 
    double maxEXP_arr[NUM_NODES]; //maximum expression for all nodes
   
    double EXP_arr[NUM_RANDOM_ICS][NUM_NODES];
    double fX_arr_norm[NUM_RANDOM_ICS];
    double fX_arr[NUM_NODES];
    //double zero_arr[NUM_NODES];

    //INDEX VARIABLES:
    int count_pos=0; //keeps track of position in EXP_dict_arr 
    int count_iteration; //counts iteration over IC initialization
    int i=0; //general purpose 

    //read the simulation configations:
    char fname_cfg[30]="racipe.cfg";

    read_config(WORK_DIR,fname_cfg);

    // calculate minimum and maximum allowable expression for each node:
    cal_EXPrange(NUM_NODES,NUM_EDGES,MPR_arrv,DNR_arrv,\
                 edge_source_arrv, edge_target_arrv,\
                 edge_type_arrv, FCH_arrv, minEXP_arr, maxEXP_arr);

    //set exp_arr to zeros: 
    for (i=0;i<NUM_NODES;++i) {
        exp_arr[i]=0.0;
        fX_arr[i]=0.0;
        //zero_arr[i]=0.0;
    }
    count_iteration=0;
    while(count_iteration<NUM_RANDOM_ICS)
    { 
        // randomly select initial condition:
        set_ICs(NUM_NODES,minEXP_arr,maxEXP_arr,IC_arr);

        // estimate the stable state for the current initial condition:
        estimate_stable_expression(NUM_NODES,NUM_EDGES,ITER_FOR_ODE,\
                                   TOTAL_EULER_STEPS,EULER_STEP_SIZE,\
				                       CONVERGENCE_PROXIMITY,\
                                   TRANS_RATE_FACTOR,\
                                   MPR_arrv,DNR_arrv,node_type_arrv,
                                   edge_source_arrv,\
                                   edge_target_arrv,edge_type_arrv,\
                                   TSH_arrv,HCO_arrv,FCH_arrv,\
				                       IC_arr,exp_arr,fX_arr);

        // calculate norm of fX:
        fX_arr_norm[count_iteration]=cal_norm(fX_arr, NUM_NODES);

        //save the exp_arr to EXP_dict_arr: 
        //if any value is found <= zero, assign it min value
        for(i=0;i<NUM_NODES;i++){
            EXP_dict_arr[count_pos+i]=exp_arr[i]>0?exp_arr[i]:minEXP_arr[i];
            EXP_arr[count_iteration][i]=exp_arr[i]>0?exp_arr[i]:minEXP_arr[i];
        }
        count_pos+=NUM_NODES;
        count_iteration+=1;
    } //end of while(count_iteration<NUM_RANDOM_ICS) 

    
    // cluster the stable state solutions:
    cluster_solutions(WORK_DIR, \
                      FNAME_STATES, FNAME_LIMITCYCLES, FNAME_SUMMARY,\
                      MODEL_NO, NUM_NODES,NUM_EDGES,\
                      NUM_RANDOM_ICS,ITER_FOR_ODE,\
                      EULER_SIM_TIME,\
                      EULER_STEP_SIZE,\
                      CONVERGENCE_PROXIMITY,\
                      TRANS_RATE_FACTOR,\
                      MPR_arrv,\
                      DNR_arrv,\
                      node_type_arrv,\
                      edge_source_arrv,\
                      edge_target_arrv,\
                      edge_type_arrv,\
                      TSH_arrv,\
                      HCO_arrv,\
                      FCH_arrv,\
                      fX_arr_norm,\
                      EXP_arr); 
    return;
}

/*------------------------------------------------------------------*/
void find_solutions_sstate(char *WORK_DIR, \
                           char *FNAME_STATES, \
                           char *FNAME_LIMITCYCLES, \
                           char *FNAME_SUMMARY, \
                           const int MODEL_NO,\
                           int NUM_NODES,int NUM_EDGES,\
                           int NUM_RANDOM_ICS,int ITER_FOR_ODE,\
                           double EULER_SIM_TIME,\
                           double EULER_STEP_SIZE,\
                           long double CONVERGENCE_PROXIMITY,\
                           double TRANS_RATE_FACTOR,\
                           const double *std_st_exp_arrv,\
                           const double *MPR_arrv,\
                           const double *DNR_arrv,\
                           const int *node_type_arrv,\
                           const int *edge_source_arrv,\
                           const int *edge_target_arrv,\
                           const int *edge_type_arrv,\
                           const double *TSH_arrv,\
                           const int *HCO_arrv,\
                           const double *FCH_arrv,\
                           double *EXP_dict_arrv) 
/*------------------------------------------------------------------
This function is similar to the function find_solutions but 
uses the supplied steady state as the initial condition to 
carry out the simulations
--------------------------------------------------------------------*/
{
    //CONSTANTS:
    const int TOTAL_EULER_STEPS=(int) (EULER_SIM_TIME/EULER_STEP_SIZE);

    //VARIABLES:
    double *EXP_dict_arr=(double *) EXP_dict_arrv;
    double IC_arr[NUM_NODES]; //saves ICs generated by set_ICs()
    double exp_arr[NUM_NODES]; //saves exps from estimate_stable_expression()

    double minEXP_arr[NUM_NODES]; //minimum expression for all nodes 
    double maxEXP_arr[NUM_NODES]; //maximum expression for all nodes
   
    double EXP_arr[NUM_RANDOM_ICS][NUM_NODES];
    double fX_arr_norm[NUM_RANDOM_ICS];
    double fX_arr[NUM_NODES];
    double zero_arr[NUM_NODES];

    //INDEX VARIABLES:
    int count_pos=0; //keeps track of position in EXP_dict_arr 
    int count_iteration; //counts iteration over IC initialization
    int i=0; //general purpose 

    //read the simulation configations:
    char fname_cfg[30]="racipe.cfg";

    read_config(WORK_DIR,fname_cfg);

   
    // calculate minimum and maximum allowable expression for each node:
    cal_EXPrange(NUM_NODES,NUM_EDGES,MPR_arrv,DNR_arrv,\
                 edge_source_arrv, edge_target_arrv,\
                 edge_type_arrv, FCH_arrv, minEXP_arr, maxEXP_arr);
    

   /* 
    printf("\nNODES: %d\n", NUM_NODES);
    printf("\n%s\n", "minimum node expressions:");
    for (i=0;i<NUM_NODES;++i) {
      printf("%f\t", minEXP_arr[i]);
    }
    printf("\n\n");
    printf("\n%s\n", "maximum node expressions:");
    for (i=0;i<NUM_NODES;++i) {
      printf("%f\t", maxEXP_arr[i]);
    }

    printf("\n");
    exit(0); 
    */ 

    //set exp_arr to zeros: 
    for (i=0;i<NUM_NODES;++i) {
        exp_arr[i]=0.0;
        fX_arr[i]=0.0;
        zero_arr[i]=0.0;
    }

    count_iteration=0; // needed to control indexing in EXP_arr
    // randomly select initial condition:
    //set_ICs(NUM_NODES,minEXP_arr,maxEXP_arr,IC_arr);

    // set steady state as the initial condition:
    set_ICs_by_sstate(NUM_NODES, std_st_exp_arrv, IC_arr);

    // estimate the stable state for the current initial condition:
    estimate_stable_expression(NUM_NODES,NUM_EDGES,ITER_FOR_ODE,\
                               TOTAL_EULER_STEPS,EULER_STEP_SIZE,\
				                   CONVERGENCE_PROXIMITY,\
                               TRANS_RATE_FACTOR,\
                               MPR_arrv,DNR_arrv,node_type_arrv,
                               edge_source_arrv,\
                               edge_target_arrv,edge_type_arrv,\
                               TSH_arrv,HCO_arrv,FCH_arrv,\
				                   IC_arr,exp_arr,fX_arr);

    for(i=0;i<NUM_NODES;i++){
        exp_arr[i]=exp_arr[i]<ZERO?ZERO:exp_arr[i];
    }


    //SAVE SOLUTIONS: expr_arr
    FILE *fh_states;
    fh_states=fopen(FNAME_STATES,"a");
    int j;
    int k;

    //write a new line to move the file pointer to the next line 
    fprintf(fh_states,"%d\t",MODEL_NO);  //write model index
    fprintf(fh_states,"%d\t",1); //write total solution
    fprintf(fh_states,"%d\t",1); //write solution index

    for(k=0;k<NUM_NODES;k++){    //write gene levels: log base 2 form 
        fprintf(fh_states,"%10.6f\t",log(exp_arr[k])/log(2));
    }
    fprintf(fh_states,"\n");


    fflush(fh_states);
    fclose(fh_states);

    // Update summary file:
    FILE *fh_summary;
    fh_summary=fopen(FNAME_SUMMARY,"a");
    fprintf(fh_summary,"%d\t%d\t%d\t%8.6f\n",MODEL_NO, 0, 0, 0.0);
    fflush(fh_summary);
    fclose(fh_summary); 

    return;
}

/*-----------------------------------------------------------------------*/
void find_traj_random_IC(char *WORK_DIR, \
                         char *FNAME_STATES, \
                         char *FNAME_LIMITCYCLES, \
                         char *FNAME_SUMMARY, \
                         const int MODEL_NO,\
                         int NUM_NODES,\
                         int NUM_EDGES,\
                         int NUM_RANDOM_ICS,int ITER_FOR_ODE,\
                         double EULER_SIM_TIME,\
                         double EULER_STEP_SIZE,\
                         long double CONVERGENCE_PROXIMITY,\
                         double TRANS_RATE_FACTOR,\
                         //const double *std_st_exp_arrv,
                         const double *MPR_arrv,\
                         const double *DNR_arrv,\
                         const int *node_type_arrv,\
                         const int *edge_source_arrv,\
                         const int *edge_target_arrv,\
                         const int *edge_type_arrv,\
                         const double *TSH_arrv,\
                         const int *HCO_arrv,\
                         const double *FCH_arrv)
/*------------------------------------------------------------------
This function finds trajectory of a system by using the  
supplied steady stable states as the initial condition. 
--------------------------------------------------------------------*/
{
    //CONSTANTS:
    const int TOTAL_EULER_STEPS=(int) (EULER_SIM_TIME/EULER_STEP_SIZE);

    const double TRAJ_SIM_STEP_SIZE=sim_config.LIMIT_CYCLE_SIM_STEP_SIZE;

    double IC_arr[NUM_NODES]; //saves ICs generated by set_ICs()
    double minEXP_arr[NUM_NODES]; //minimum expression for all nodes 
    double maxEXP_arr[NUM_NODES]; //maximum expression for all nodes
   
    //INDEX VARIABLES:
    int i=0; //general purpose 

    // Read the simulation configations:
    char fname_cfg[30]="racipe.cfg";

    double TRAJ_start_exp_arr[NUM_NODES];

    //OPEN states file: 
    FILE *fh_states;
    fh_states=fopen(FNAME_STATES, "a");

    //OPEN summary file: 
    FILE *fh_summary;
    fh_summary=fopen(FNAME_SUMMARY, "a");


    //Update and close summary file: 
    fprintf(fh_summary,"%d\t%d\t%d\t%8.6f\n",MODEL_NO, 0, 0, 0.0);
    fflush(fh_summary);
    fclose(fh_summary); 

    read_config(WORK_DIR,fname_cfg);


    // Calculate minimum and maximum allowable expression for each node:
    cal_EXPrange(NUM_NODES,NUM_EDGES,MPR_arrv,DNR_arrv,\
                 edge_source_arrv, edge_target_arrv,\
                 edge_type_arrv, FCH_arrv, minEXP_arr, maxEXP_arr);
    
    // Calculate ICs:  
    set_ICs(NUM_NODES,minEXP_arr,maxEXP_arr,IC_arr);

    // Calculate trajectory:
    cal_long_traj(fh_states, \
                  MODEL_NO,\
                  NUM_NODES,NUM_EDGES,\
                  TOTAL_EULER_STEPS,\
                  EULER_STEP_SIZE,\
                  CONVERGENCE_PROXIMITY,\
                  TRANS_RATE_FACTOR,\
                  MPR_arrv,\
                  DNR_arrv,\
                  node_type_arrv,\
                  edge_source_arrv,\
                  edge_target_arrv,\
                  edge_type_arrv,\
                  TSH_arrv,\
                  HCO_arrv,\
                  FCH_arrv,\
                  IC_arr);
                  //std_st_exp_arrv);

    //CLOSE states file: 
    fflush(fh_states);
    fclose(fh_states);


    return;
}




/*-----------------------------------------------------------------------*/
void find_traj_sstate_signaled(char *WORK_DIR, \
                               char *FNAME_STATES, \
                               char *FNAME_LIMITCYCLES, \
                               char *FNAME_SUMMARY, \
                               const int MODEL_NO,\
                               int NUM_NODES,\
                               int NUM_EDGES,\
                               int NUM_RANDOM_ICS,int ITER_FOR_ODE,\
                               double EULER_SIM_TIME,\
                               double EULER_STEP_SIZE,\
                               long double CONVERGENCE_PROXIMITY,\
                               double TRANS_RATE_FACTOR,\
                               const double *std_st_exp_arrv,\
                               const double *MPR_arrv,\
                               const double *DNR_arrv,\
                               const int *node_type_arrv,\
                               const int *edge_source_arrv,\
                               const int *edge_target_arrv,\
                               const int *edge_type_arrv,\
                               const double *TSH_arrv,\
                               const int *HCO_arrv,\
                               const double *FCH_arrv)
/*------------------------------------------------------------------
This function finds trajectory of a system by using the  
supplied steady stable states as the initial condition. 
--------------------------------------------------------------------*/
{
    //CONSTANTS:
    const int TOTAL_EULER_STEPS=(int) (EULER_SIM_TIME/EULER_STEP_SIZE);

    const double TRAJ_SIM_STEP_SIZE=sim_config.LIMIT_CYCLE_SIM_STEP_SIZE;

    double minEXP_arr[NUM_NODES]; //minimum expression for all nodes 
    double maxEXP_arr[NUM_NODES]; //maximum expression for all nodes
   
    //INDEX VARIABLES:
    int i=0; //general purpose 

    // Read the simulation configations:
    char fname_cfg[30]="racipe.cfg";

    double TRAJ_start_exp_arr[NUM_NODES];

    //OPEN states file: 
    FILE *fh_states;
    fh_states=fopen(FNAME_STATES, "a");

    //OPEN summary file: 
    FILE *fh_summary;
    fh_summary=fopen(FNAME_SUMMARY, "a");


    //Update and close summary file: 
    fprintf(fh_summary,"%d\t%d\t%d\t%8.6f\n",MODEL_NO, 0, 0, 0.0);
    fflush(fh_summary);
    fclose(fh_summary); 

    read_config(WORK_DIR,fname_cfg);

    // Calculate minimum and maximum allowable expression for each node:
    cal_EXPrange(NUM_NODES,NUM_EDGES,MPR_arrv,DNR_arrv,\
                 edge_source_arrv, edge_target_arrv,\
                 edge_type_arrv, FCH_arrv, minEXP_arr, maxEXP_arr);
    
    // Calculate trajectory:
    cal_long_traj(fh_states, \
                  MODEL_NO,\
                  NUM_NODES,NUM_EDGES,\
                  TOTAL_EULER_STEPS,\
                  EULER_STEP_SIZE,\
                  CONVERGENCE_PROXIMITY,\
                  TRANS_RATE_FACTOR,\
                  MPR_arrv,\
                  DNR_arrv,\
                  node_type_arrv,\
                  edge_source_arrv,\
                  edge_target_arrv,\
                  edge_type_arrv,\
                  TSH_arrv,\
                  HCO_arrv,\
                  FCH_arrv,\
                  std_st_exp_arrv);

    //CLOSE states file: 
    fflush(fh_states);
    fclose(fh_states);


    return;
}

/*-----------------------------------------------------------------------*/
void cal_long_traj_with_updated_MPR(FILE *fh_states, \
                   int MODEL_NO,\
                   int NUM_NODES,int NUM_EDGES,\
                   int SIM_STEPS,\
                   double SIM_STEP_SIZE,\
                   long double CONVERGENCE_PROXIMITY,\
                   double TRANS_RATE_FACTOR,\
                   double *MPR_arrv,\
                   const double *DNR_arrv,\
                   const int *node_type_arrv,\
                   const int *edge_source_arrv,\
                   const int *edge_target_arrv,\
                   const int *edge_type_arrv,\
                   const double *TSH_arrv,\
                   const int *HCO_arrv,\
                   const double *FCH_arrv,\
                   const double *start_exp_arr)
{
    double fX_arr[NUM_NODES]; //fX_arr saves fX values in each Euler step
    double curr_exp_arr[NUM_NODES];
    double next_exp_arr[NUM_NODES];
    int i;

    int INTERVAL_BETWEEN_POINTS=10; //100;

    //Copy the start expressions to a local variable:
    for (i=0;i<NUM_NODES;++i) {
        curr_exp_arr[i]=start_exp_arr[i]; 
    }

     //write a the first point of the trajectory to the file:
     fprintf(fh_states,"%d\t",MODEL_NO);  //write model index
     fprintf(fh_states,"%d\t",1); //write total solution
     fprintf(fh_states,"%d\t",1);     //write solution index
     for(i=0;i<NUM_NODES;i++){            //write gene levels 
         fprintf(fh_states,"%10.6f\t",log(curr_exp_arr[i])/log(2));
     }
     fprintf(fh_states,"\n");

    int count_step=0;
    while(count_step<SIM_STEPS)
    {
        cal_fX(NUM_NODES,NUM_EDGES,SIM_STEP_SIZE,\
               TRANS_RATE_FACTOR,\
               MPR_arrv,\
               DNR_arrv,\
               node_type_arrv,edge_source_arrv,\
               edge_target_arrv,edge_type_arrv,\
               TSH_arrv,HCO_arrv,FCH_arrv,\
               curr_exp_arr,fX_arr);
        
        //Calculate next expressions:
        for (i=0;i<NUM_NODES;++i) {
             next_exp_arr[i]=curr_exp_arr[i]+fX_arr[i]*SIM_STEP_SIZE;
        }

        //copy next exp to curr exp and save curr exp
        for (i=0;i<NUM_NODES;++i){
            curr_exp_arr[i]=next_exp_arr[i]>=0?next_exp_arr[i]:0;
        }

        if(count_step%INTERVAL_BETWEEN_POINTS==0){ 
            //write a new line to move the file pointer to the next line 
            fprintf(fh_states,"%d\t",MODEL_NO);  //write model index
            fprintf(fh_states,"%d\t",1); //write total solution
            fprintf(fh_states,"%d\t",1);     //write solution index
            for(i=0;i<NUM_NODES;i++){            //write gene levels 
               fprintf(fh_states,"%10.6f\t",log(curr_exp_arr[i])/log(2));
            }
            fprintf(fh_states,"\n");
        }

        //Update step counter:
        count_step+=1;
    }
    
    return ;
}


/*-----------------------------------------------------------------------*/
void cal_long_traj(FILE *fh_states, \
                   int MODEL_NO,\
                   int NUM_NODES,int NUM_EDGES,\
                   int SIM_STEPS,\
                   double SIM_STEP_SIZE,\
                   long double CONVERGENCE_PROXIMITY,\
                   double TRANS_RATE_FACTOR,\
                   const double *MPR_arrv,\
                   const double *DNR_arrv,\
                   const int *node_type_arrv,\
                   const int *edge_source_arrv,\
                   const int *edge_target_arrv,\
                   const int *edge_type_arrv,\
                   const double *TSH_arrv,\
                   const int *HCO_arrv,\
                   const double *FCH_arrv,\
                   const double *start_exp_arr)
{
    double fX_arr[NUM_NODES]; //fX_arr saves fX values in each Euler step
    double curr_exp_arr[NUM_NODES];
    double next_exp_arr[NUM_NODES];
    int i;

    int INTERVAL_BETWEEN_POINTS=100;

    //Copy the start expressions to a local variable:
    for (i=0;i<NUM_NODES;++i) {
        curr_exp_arr[i]=start_exp_arr[i]; 
    }

     //write a new line to move the file pointer to the next line 
     fprintf(fh_states,"%d\t",MODEL_NO);  //write model index
     fprintf(fh_states,"%d\t",1); //write total solution
     fprintf(fh_states,"%d\t",1);     //write solution index
     for(i=0;i<NUM_NODES;i++){            //write gene levels 
         fprintf(fh_states,"%10.6f\t",log(curr_exp_arr[i])/log(2));
     }
     fprintf(fh_states,"\n");

    int count_step=0;
    while(count_step<SIM_STEPS)
    {
        cal_fX(NUM_NODES,NUM_EDGES,SIM_STEP_SIZE,\
               TRANS_RATE_FACTOR,\
               MPR_arrv,\
               DNR_arrv,\
               node_type_arrv,edge_source_arrv,\
               edge_target_arrv,edge_type_arrv,\
               TSH_arrv,HCO_arrv,FCH_arrv,\
               curr_exp_arr,fX_arr);
        
        //Calculate next expressions:
        for (i=0;i<NUM_NODES;++i) {
             next_exp_arr[i]=curr_exp_arr[i]+fX_arr[i]*SIM_STEP_SIZE;
        }

        //copy next exp to curr exp and save curr exp
        for (i=0;i<NUM_NODES;++i){
            curr_exp_arr[i]=next_exp_arr[i]>=0?next_exp_arr[i]:0;
        }

        if(count_step%INTERVAL_BETWEEN_POINTS==0){ 
            //write a new line to move the file pointer to the next line 
            fprintf(fh_states,"%d\t",MODEL_NO);  //write model index
            fprintf(fh_states,"%d\t",1); //write total solution
            fprintf(fh_states,"%d\t",1);     //write solution index
            for(i=0;i<NUM_NODES;i++){            //write gene levels 
               fprintf(fh_states,"%10.6f\t",log(curr_exp_arr[i])/log(2));
            }
            fprintf(fh_states,"\n");
        }

        //Update step counter:
        count_step+=1;
    }
    
    return ;
}

/*-----------------------------------------------------------------------*/
void cal_traj(int NUM_NODES,int NUM_EDGES,\
              int SIM_STEPS,\
              double SIM_STEP_SIZE,\
              long double CONVERGENCE_PROXIMITY,\
              double TRANS_RATE_FACTOR,\
              double *MPR_arrv,\
              const double *DNR_arrv,\
              const int *node_type_arrv,\
              const int *edge_source_arrv,\
              const int *edge_target_arrv,\
              const int *edge_type_arrv,\
              const double *TSH_arrv,\
              const int *HCO_arrv,\
              const double *FCH_arrv,\
              const int SIGNALING_NODE_ID,\
              double *MPR_along_traj,\
              double *start_exp_arr,\
              double **TRAJ_exp_arr)
{
    double fX_arr[NUM_NODES]; //fX_arr saves fX values in each Euler step
    double curr_exp_arr[NUM_NODES];
    double next_exp_arr[NUM_NODES];
    int i;

    printf("\nMPR in cal_traj: %10.6f\n", MPR_arrv[SIGNALING_NODE_ID]);
    printf("\nMPR in cal_traj: %10.6f\n", MPR_arrv[21]);

    //Copy the start expressions to a local variable:
    for (i=0;i<NUM_NODES;++i) {
        curr_exp_arr[i]=start_exp_arr[i]; 
    }

    int count_step=0;
    while(count_step<SIM_STEPS)
    {
        //MPR_arrv[SIGNALING_NODE_ID]=MPR_along_traj[count_step];

        cal_fX(NUM_NODES,NUM_EDGES,SIM_STEP_SIZE,\
               TRANS_RATE_FACTOR,\
               MPR_arrv,\
               DNR_arrv,\
               node_type_arrv,edge_source_arrv,\
               edge_target_arrv,edge_type_arrv,\
               TSH_arrv,HCO_arrv,FCH_arrv,\
               curr_exp_arr,fX_arr);
        
        //Calculate next expressions:
        for (i=0;i<NUM_NODES;++i) {
             next_exp_arr[i]=curr_exp_arr[i]+fX_arr[i]*SIM_STEP_SIZE;
        }

        //copy next exp to curr exp and save curr exp
        for (i=0;i<NUM_NODES;++i){
            curr_exp_arr[i]=next_exp_arr[i]>=0?next_exp_arr[i]:0;
            TRAJ_exp_arr[count_step][i]=curr_exp_arr[i];
        }

        //Update step counter:
        count_step+=1;
    }
    return ;
}

/*-----------------------------------------------------------------------*/
void find_traj_sstate_incr_sig_gradually(char *WORK_DIR, \
                           char *FNAME_STATES, \
                           char *FNAME_LIMITCYCLES, \
                           char *FNAME_SUMMARY, \
                           const int MODEL_NO,\
                           int NUM_NODES,\
                           int NUM_EDGES,\
                           int NUM_RANDOM_ICS,int ITER_FOR_ODE,\
                           double EULER_SIM_TIME,\
                           double EULER_STEP_SIZE,\
                           long double CONVERGENCE_PROXIMITY,\
                           double TRANS_RATE_FACTOR,\
                           const double *std_st_exp_arrv,\
                           const double *MPR_arrv,\
                           const double *DNR_arrv,\
                           const int *node_type_arrv,\
                           const int *edge_source_arrv,\
                           const int *edge_target_arrv,\
                           const int *edge_type_arrv,\
                           const double *TSH_arrv,\
                           const int *HCO_arrv,\
                           const double *FCH_arrv,\
                           const int SIGNALING_NODE_ID,\
                           const double FCHANGE)
/*------------------------------------------------------------------
This function finds trajectory of a system by using the  
supplied steady stable states as the initial condition. 
--------------------------------------------------------------------*/
{
    //CONSTANTS:
    const int TOTAL_EULER_STEPS=(int) (EULER_SIM_TIME/EULER_STEP_SIZE);

    //VARIABLES:
    double minEXP_arr[NUM_NODES]; //minimum expression for all nodes 
    double maxEXP_arr[NUM_NODES]; //maximum expression for all nodes
   
    double EXP_arr[NUM_RANDOM_ICS][NUM_NODES];
    double fX_arr_norm[NUM_RANDOM_ICS];

    int i=0; //general purpose 

    // Read the simulation configations:
    char fname_cfg[30]="racipe.cfg";

    double TRAJ_start_exp_arr[NUM_NODES];
    double TRAJ_end_exp_arr[NUM_NODES];

    //DEFINE FILE HEADER:
    FILE *fh_states;
    fh_states=fopen(FNAME_STATES, "a");

    char fname_MPR_TRAJ[400]="\0";
    strcat(fname_MPR_TRAJ, WORK_DIR);
    strcat(fname_MPR_TRAJ, "/");
    strcat(fname_MPR_TRAJ, "MPR_along_traj.txt");
    FILE *fh_MPR;
    //fh_MPR=fopen(fname_MPR_TRAJ, "w");

    double MPR_arr[NUM_NODES];

    int SIM_TIME_SIG_CHANGING=25; //100;

    int SIM_STEPS_SIG_CHANGING=SIM_TIME_SIG_CHANGING/EULER_STEP_SIZE;

    const double DELTA_MPR_FACTOR = (FCHANGE-1)/SIM_STEPS_SIG_CHANGING;

    double MPR_sig_increasing[SIM_STEPS_SIG_CHANGING];

    double MPR_factor_prev=1.0;
    double MPR_factor_next=0.0;

    // Create a vector of MPR signals for ramp (uphill):
    MPR_sig_increasing[0] = MPR_arrv[SIGNALING_NODE_ID] * MPR_factor_prev;
    for(i=1; i<SIM_STEPS_SIG_CHANGING; i++){
         MPR_factor_next = MPR_factor_prev + DELTA_MPR_FACTOR;
         MPR_sig_increasing[i] = MPR_arrv[SIGNALING_NODE_ID] * MPR_factor_next;
         MPR_factor_prev = MPR_factor_next;
    }

   // Copy MPR arr to the local variable:
    for (i=0;i<NUM_NODES;++i) {
        MPR_arr[i]=MPR_arrv[i];
    }

   // Update local MPR variable with the peak MPR value for signaling node:
    MPR_arr[SIGNALING_NODE_ID]=MPR_sig_increasing[SIM_STEPS_SIG_CHANGING-1];
    //MPR_arr[SIGNALING_NODE_ID]=114.56;


    // Write the MPR signal trajectory to the file:
    //save_mpr_traj_sstate(fh_MPR, MODEL_NO, MPR_sig_increasing, SIM_STEPS_SIG_CHANGING);
    //fclose(fh_MPR); 

    read_config(WORK_DIR,fname_cfg);

    // Calculate minimum and maximum allowable expression for each node:
    cal_EXPrange(NUM_NODES,NUM_EDGES,MPR_arr,DNR_arrv,\
                 edge_source_arrv, edge_target_arrv,\
                 edge_type_arrv, FCH_arrv, minEXP_arr, maxEXP_arr);
    
    // Set trajectory start expressions variable passed as a parameter:
    for (i=0;i<NUM_NODES;++i) {
        TRAJ_start_exp_arr[i]=std_st_exp_arrv[i];
    }

    // Set TGFbeta expression to mean expression of M state:
    //TRAJ_start_exp_arr[SIGNALING_NODE_ID]=114.56;

    //printf("\n%s%f\n", "MPR at time 0: ", MPR_arr[SIGNALING_NODE_ID]);
    //printf("%s%f\n","Start exp at time 0: ", TRAJ_start_exp_arr[SIGNALING_NODE_ID]);
   
    cal_traj_given_MPR_along(fh_states,\
                             MODEL_NO,\
                             NUM_NODES, NUM_EDGES,\
                             SIM_STEPS_SIG_CHANGING,\
                             EULER_STEP_SIZE,\
                             CONVERGENCE_PROXIMITY,\
                             TRANS_RATE_FACTOR,\
                             MPR_arr,\
                             DNR_arrv,\
                             node_type_arrv,\
                             edge_source_arrv,\
                             edge_target_arrv,\
                             edge_type_arrv,\
                             TSH_arrv,\
                             HCO_arrv,\
                             FCH_arrv,\
                             SIGNALING_NODE_ID,\
                             MPR_sig_increasing,\
                             TRAJ_start_exp_arr,\
                             TRAJ_end_exp_arr);
   
    /*
    printf("\n");
    for (i=0;i<NUM_NODES;++i){
        printf("%f\t",TRAJ_end_exp_arr[i]);
    }
    printf("\n");
   */


   /* 
    // Set trajectory start expressions for the next segment of simulations:
    for (i=0;i<NUM_NODES;++i) {
        TRAJ_start_exp_arr[i]=TRAJ_end_exp_arr[i];
    } 

    // Calculate trajectory at constant elevated signal:
    cal_long_traj_with_updated_MPR(fh_states, \
                  MODEL_NO,\
                  NUM_NODES,NUM_EDGES,\
                  TOTAL_EULER_STEPS,\
                  EULER_STEP_SIZE,\
                  CONVERGENCE_PROXIMITY,\
                  TRANS_RATE_FACTOR,\
                  MPR_arr,\
                  DNR_arrv,\
                  node_type_arrv,\
                  edge_source_arrv,\
                  edge_target_arrv,\
                  edge_type_arrv,\
                  TSH_arrv,\
                  HCO_arrv,\
                  FCH_arrv,\
                  TRAJ_start_exp_arr);

   */

    //CLOSE states file: 
    fflush(fh_states);
    fclose(fh_states);

    //exit(0);

    return;
}

/*-----------------------------------------------------------------------*/
void find_traj_sstate_decr_sig_gradually(char *WORK_DIR, \
                           char *FNAME_STATES, \
                           char *FNAME_LIMITCYCLES, \
                           char *FNAME_SUMMARY, \
                           const int MODEL_NO,\
                           int NUM_NODES,\
                           int NUM_EDGES,\
                           int NUM_RANDOM_ICS,int ITER_FOR_ODE,\
                           double EULER_SIM_TIME,\
                           double EULER_STEP_SIZE,\
                           long double CONVERGENCE_PROXIMITY,\
                           double TRANS_RATE_FACTOR,\
                           const double *std_st_exp_arrv,\
                           const double *MPR_arrv,\
                           const double *DNR_arrv,\
                           const int *node_type_arrv,\
                           const int *edge_source_arrv,\
                           const int *edge_target_arrv,\
                           const int *edge_type_arrv,\
                           const double *TSH_arrv,\
                           const int *HCO_arrv,\
                           const double *FCH_arrv,\
                           const int SIGNALING_NODE_ID,\
                           const double FCHANGE)
{

    //printf("%f\n", EULER_SIM_TIME);
    //exit(0);
    //CONSTANTS:
    const int TOTAL_EULER_STEPS=(int) (EULER_SIM_TIME/EULER_STEP_SIZE);

    //VARIABLES:
    double minEXP_arr[NUM_NODES]; //minimum expression for all nodes 
    double maxEXP_arr[NUM_NODES]; //maximum expression for all nodes
   
    double EXP_arr[NUM_RANDOM_ICS][NUM_NODES];
    double fX_arr_norm[NUM_RANDOM_ICS];

    int i=0; //general purpose 

    // Read the simulation configations:
    char fname_cfg[30]="racipe.cfg";

    double TRAJ_start_exp_arr[NUM_NODES];
    double TRAJ_end_exp_arr[NUM_NODES];

    //DEFINE FILE HEADER:
    FILE *fh_states;
    fh_states=fopen(FNAME_STATES, "a");
    char fname_MPR_TRAJ[400]="\0";
    strcat(fname_MPR_TRAJ, WORK_DIR);
    strcat(fname_MPR_TRAJ, "/");
    strcat(fname_MPR_TRAJ, "MPR_along_traj.txt");
    FILE *fh_MPR;
    //fh_MPR=fopen(fname_MPR_TRAJ, "w");

    double MPR_arr[NUM_NODES];

    int SIM_TIME_SIG_CHANGING=25; //100; 

    int SIM_STEPS_SIG_CHANGING=SIM_TIME_SIG_CHANGING/EULER_STEP_SIZE;

    //printf("%f\n",FCHANGE);

    //const long double DELTA_MPR_FACTOR = (FCHANGE-1)/SIM_STEPS_SIG_CHANGING;
    const double DELTA_MPR_FACTOR = (FCHANGE-1)/SIM_STEPS_SIG_CHANGING;
    //printf("%f\n",DELTA_MPR_FACTOR);

    //const double D = (FCHANGE)/SIM_STEPS_SIG_CHANGING;
    //printf("%f\n",D);

    //printf("%s\n","done in c");
    //exit(0);

    double MPR_sig_increasing[SIM_STEPS_SIG_CHANGING];

    double MPR_factor_prev=1.0;
    double MPR_factor_next=0.0;

    // Create a vector of MPR signals for ramp (uphill):
    MPR_sig_increasing[0] = MPR_arrv[SIGNALING_NODE_ID] * MPR_factor_prev;
    //MPR_sig_increasing[0] = MPR_arrv[SIGNALING_NODE_ID] / MPR_factor_prev;
    
    for(i=1; i<SIM_STEPS_SIG_CHANGING; i++){
         MPR_factor_next = MPR_factor_prev + DELTA_MPR_FACTOR;
         MPR_sig_increasing[i] = MPR_arrv[SIGNALING_NODE_ID] * MPR_factor_next;
         //MPR_factor_next = MPR_factor_prev - DELTA_MPR_FACTOR;
         //MPR_sig_increasing[i] = MPR_arrv[SIGNALING_NODE_ID] / MPR_factor_next;

         MPR_factor_prev = MPR_factor_next;
    }

   // Copy MPR arr to the local variable:
    for (i=0;i<NUM_NODES;++i) {
        MPR_arr[i]=MPR_arrv[i];
    }

   // Update local MPR variable with the peak MPR value for signaling node:
    MPR_arr[SIGNALING_NODE_ID]=MPR_sig_increasing[SIM_STEPS_SIG_CHANGING-1];
    //MPR_arr[SIGNALING_NODE_ID]=MPR_arrv[SIGNALING_NODE_ID] * pow(2,-8);

    // Write the MPR signal trajectory to the file:
    //save_mpr_traj_sstate(fh_MPR, MODEL_NO, MPR_sig_increasing, SIM_STEPS_SIG_CHANGING);
    //fclose(fh_MPR); 

    read_config(WORK_DIR,fname_cfg);

    // Calculate minimum and maximum allowable expression for each node:
    cal_EXPrange(NUM_NODES,NUM_EDGES,MPR_arr,DNR_arrv,\
                 edge_source_arrv, edge_target_arrv,\
                 edge_type_arrv, FCH_arrv, minEXP_arr, maxEXP_arr);
    
    // Set trajectory start expressions variable passed as a parameter:
    for (i=0;i<NUM_NODES;++i) {
        TRAJ_start_exp_arr[i]=std_st_exp_arrv[i];
    }

    //printf("\n%s%f\n", "MPR at time 0: ", MPR_arr[SIGNALING_NODE_ID]);
    //printf("%s%f\n","Start exp at time 0: ", TRAJ_start_exp_arr[SIGNALING_NODE_ID]);

    
    cal_traj_given_MPR_along(fh_states,\
                             MODEL_NO,\
                             NUM_NODES, NUM_EDGES,\
                             SIM_STEPS_SIG_CHANGING,\
                             EULER_STEP_SIZE,\
                             CONVERGENCE_PROXIMITY,\
                             TRANS_RATE_FACTOR,\
                             MPR_arr,\
                             DNR_arrv,\
                             node_type_arrv,\
                             edge_source_arrv,\
                             edge_target_arrv,\
                             edge_type_arrv,\
                             TSH_arrv,\
                             HCO_arrv,\
                             FCH_arrv,\
                             SIGNALING_NODE_ID,\
                             MPR_sig_increasing,\
                             TRAJ_start_exp_arr,\
                             TRAJ_end_exp_arr);
    
    
    /*
    printf("\n");
    for (i=0;i<NUM_NODES;++i){
        printf("%f\t",TRAJ_end_exp_arr[i]);
    }
    printf("\n");
    */
   
    /* 
    // Set trajectory start expressions for the next segment of simulations:
    for (i=0;i<NUM_NODES;++i) {
        TRAJ_start_exp_arr[i]=TRAJ_end_exp_arr[i];
    } 

    // Calculate trajectory at constant elevated signal:
    cal_long_traj_with_updated_MPR(fh_states, \
                  MODEL_NO,\
                  NUM_NODES,NUM_EDGES,\
                  TOTAL_EULER_STEPS,\
                  EULER_STEP_SIZE,\
                  CONVERGENCE_PROXIMITY,\
                  TRANS_RATE_FACTOR,\
                  MPR_arr,\
                  DNR_arrv,\
                  node_type_arrv,\
                  edge_source_arrv,\
                  edge_target_arrv,\
                  edge_type_arrv,\
                  TSH_arrv,\
                  HCO_arrv,\
                  FCH_arrv,\
                  TRAJ_start_exp_arr);
    */

    //CLOSE states file: 
    fflush(fh_states);
    fclose(fh_states);

    //exit(0);

    return;
}

/*-----------------------------------------------------------------------*/
void cal_traj_given_MPR_along(FILE *fh_states, \
                              int MODEL_NO,\
                              int NUM_NODES,int NUM_EDGES,\
                              int SIM_STEPS,\
                              double SIM_STEP_SIZE,\
                              long double CONVERGENCE_PROXIMITY,\
                              double TRANS_RATE_FACTOR,\
                              double *MPR_arrv,\
                              const double *DNR_arrv,\
                              const int *node_type_arrv,\
                              const int *edge_source_arrv,\
                              const int *edge_target_arrv,\
                              const int *edge_type_arrv,\
                              const double *TSH_arrv,\
                              const int *HCO_arrv,\
                              const double *FCH_arrv,\
                              const int SIGNALING_NODE_ID,\
                              double *MPR_along_traj,\
                              double *start_exp_arr,\
                              double *end_exp_arr)
{
    double fX_arr[NUM_NODES]; //fX_arr saves fX values in each Euler step
    double curr_exp_arr[NUM_NODES];
    double next_exp_arr[NUM_NODES];
    int i;

    int INTERVAL_BETWEEN_POINTS=100; //100;

    //Copy the start expressions to a local variable:
    for (i=0;i<NUM_NODES;++i) {
        curr_exp_arr[i]=start_exp_arr[i]; 
    }

     //write a the first point of the trajectory to the file:
     fprintf(fh_states,"%d\t",MODEL_NO);  //write model index
     fprintf(fh_states,"%d\t",1); //write total solution
     fprintf(fh_states,"%d\t",1);     //write solution index
     for(i=0;i<NUM_NODES;i++){            //write gene levels 
         fprintf(fh_states,"%10.6f\t",log(curr_exp_arr[i])/log(2));
     }
     fprintf(fh_states,"\n");

    int count_step=0;
    while(count_step<SIM_STEPS)
    {
        MPR_arrv[SIGNALING_NODE_ID]=MPR_along_traj[count_step];

        cal_fX(NUM_NODES,NUM_EDGES,SIM_STEP_SIZE,\
               TRANS_RATE_FACTOR,\
               MPR_arrv,\
               DNR_arrv,\
               node_type_arrv,edge_source_arrv,\
               edge_target_arrv,edge_type_arrv,\
               TSH_arrv,HCO_arrv,FCH_arrv,\
               curr_exp_arr,fX_arr);
        
        //Calculate next expressions:
        for (i=0;i<NUM_NODES;++i) {
             next_exp_arr[i]=curr_exp_arr[i]+fX_arr[i]*SIM_STEP_SIZE;
        }

        //copy next exp to curr exp and save curr exp
        for (i=0;i<NUM_NODES;++i){
            curr_exp_arr[i]=next_exp_arr[i]>=0?next_exp_arr[i]:0;
        }

        if(count_step%INTERVAL_BETWEEN_POINTS==0){ 
            //write a new line to move the file pointer to the next line 
            fprintf(fh_states,"%d\t",MODEL_NO);  //write model index
            fprintf(fh_states,"%d\t",1); //write total solution
            fprintf(fh_states,"%d\t",1);     //write solution index
            for(i=0;i<NUM_NODES;i++){            //write gene levels 
               fprintf(fh_states,"%10.6f\t",log(curr_exp_arr[i])/log(2));
            }
            fprintf(fh_states,"\n");
        }

        //Update step counter:
        count_step+=1;
    }

    // Copy traj end expression to the return variable:
    //printf("\n");
    for (i=0;i<NUM_NODES;++i){
        end_exp_arr[i]=curr_exp_arr[i];
    //    printf("%f\t",end_exp_arr[i]);
    }
    //printf("\n");

    return ;
}

/*-----------------------------------------------------------------------*/
void find_trajectory_sstate(char *WORK_DIR, \
                           char *FNAME_STATES, \
                           char *FNAME_LIMITCYCLES, \
                           char *FNAME_SUMMARY, \
                           const int MODEL_NO,\
                           int NUM_NODES,\
                           int NUM_EDGES,\
                           int NUM_RANDOM_ICS,int ITER_FOR_ODE,\
                           double EULER_SIM_TIME,\
                           double EULER_STEP_SIZE,\
                           long double CONVERGENCE_PROXIMITY,\
                           double TRANS_RATE_FACTOR,\
                           const double *std_st_exp_arrv,\
                           const double *MPR_arrv,\
                           const double *DNR_arrv,\
                           const int *node_type_arrv,\
                           const int *edge_source_arrv,\
                           const int *edge_target_arrv,\
                           const int *edge_type_arrv,\
                           const double *TSH_arrv,\
                           const int *HCO_arrv,\
                           const double *FCH_arrv,\
                           const int SIGNALING_NODE_ID,\
                           double *EXP_dict_arrv)
/*------------------------------------------------------------------
This function finds trajectory of a system by using the  
supplied steady stable states as the initial condition. 
--------------------------------------------------------------------*/
{
    //CONSTANTS:
    const int TOTAL_EULER_STEPS=(int) (EULER_SIM_TIME/EULER_STEP_SIZE);

    const double TRAJ_SIM_STEP_SIZE=sim_config.LIMIT_CYCLE_SIM_STEP_SIZE;

    //VARIABLES:
    double *EXP_dict_arr=(double *) EXP_dict_arrv;

    double minEXP_arr[NUM_NODES]; //minimum expression for all nodes 
    double maxEXP_arr[NUM_NODES]; //maximum expression for all nodes
   
    double EXP_arr[NUM_RANDOM_ICS][NUM_NODES];
    double fX_arr_norm[NUM_RANDOM_ICS];

    //INDEX VARIABLES:
    int i=0; //general purpose 

    // Read the simulation configations:
    char fname_cfg[30]="racipe.cfg";

    double TRAJ_start_exp_arr[NUM_NODES];
    double **TRAJ_exp_arr;

    //DEFINE FILE HEADER:
    FILE *fh_STATES;
    fh_STATES=fopen(FNAME_STATES, "a");

    char FNAME_MPR[20]="./MPR.txt";
    FILE *fh_MPR;
    fh_MPR=fopen(FNAME_MPR, "a");

    double MPR_arr[NUM_NODES];

    //const double FOLD_CHANGE= 2^2; //66.11136*100;
    const double FOLD_CHANGE=pow(2, 25); //pow(2,23); //66.11136*100;
    //const double FOLD_CHANGE=pow(2, 5); //pow(2,23); //66.11136*100;
    
    int SAMPLING_DIST=100;
    //printf("%s\t%f\n", "FC: ", FOLD_CHANGE);
    //exit(0);
    int SIM_TIME_SIG_CHANGING=10; //100;
    int SIM_TIME_SIG_HI_CONSTANT=500; //8000; //2000; //100; //20
    int SIM_TIME_SIG_LO_CONSTANT=500; //2000;

    int SIM_STEPS_SIG_CHANGING=SIM_TIME_SIG_CHANGING/EULER_STEP_SIZE;
    int SIM_STEPS_SIG_HI_CONSTANT=SIM_TIME_SIG_HI_CONSTANT/EULER_STEP_SIZE;
    int SIM_STEPS_SIG_LO_CONSTANT=SIM_TIME_SIG_LO_CONSTANT/EULER_STEP_SIZE;

    const double DELTA_MPR_FACTOR = FOLD_CHANGE/SIM_STEPS_SIG_CHANGING;

    double MPR_sig_increasing[SIM_STEPS_SIG_CHANGING];
    double MPR_sig_hi_constant[SIM_STEPS_SIG_HI_CONSTANT];
    double MPR_sig_decreasing[SIM_STEPS_SIG_CHANGING];
    double MPR_sig_lo_constant[SIM_STEPS_SIG_LO_CONSTANT];

    int TOTAL_SIMSTEPS_SIGNALING=SIM_STEPS_SIG_CHANGING+\
                                 SIM_STEPS_SIG_HI_CONSTANT+\
                                 SIM_STEPS_SIG_CHANGING+\
                                 SIM_STEPS_SIG_LO_CONSTANT;
    int NO_MEM_SLOTS=TOTAL_SIMSTEPS_SIGNALING+1;

    printf("\n%lu\n",sizeof(MPR_sig_increasing)/sizeof(MPR_sig_increasing[0]));

    double MPR_factor_prev=1.0;
    double MPR_factor_next=0.0;

    // create a vector of MPR signals for ramp (uphill):
    MPR_sig_increasing[0] = MPR_arrv[SIGNALING_NODE_ID] * MPR_factor_prev;
    for(i=1; i<SIM_STEPS_SIG_CHANGING; i++){
         MPR_factor_next = MPR_factor_prev + DELTA_MPR_FACTOR;
         MPR_sig_increasing[i] = MPR_arrv[SIGNALING_NODE_ID] * MPR_factor_next;
         MPR_factor_prev = MPR_factor_next;
    }

    printf("DELTA_MPR_FACTOR: %f\n", DELTA_MPR_FACTOR);
    printf("\n%s%f\n", "MPR at time 0: ", MPR_arrv[SIGNALING_NODE_ID]);
    printf("\n%s%f\n", "MPR sig_increasing[0]: ", MPR_sig_increasing[0]);
    printf("\n%s%f\n","MPR sig_increasing[last]: ", MPR_sig_increasing[SIM_STEPS_SIG_CHANGING-1]);

    // create a vector of MPR signals for plateau: 
    for(i=0; i<SIM_STEPS_SIG_HI_CONSTANT; i++){
         MPR_sig_hi_constant[i] = MPR_sig_increasing[SIM_STEPS_SIG_CHANGING-1];
    }

    printf("\n%s%f\n", "MPR sig_hi_constant[0]: ", MPR_sig_hi_constant[0]);
    printf("\n%s%f\n","MPR sig_hi_constant[last]: ", MPR_sig_hi_constant[SIM_STEPS_SIG_HI_CONSTANT-1]);

    // create a vector of MPR signals for ramp (downhil):
    for(i=0; i<SIM_STEPS_SIG_CHANGING;i++){
         MPR_sig_decreasing[i] = MPR_sig_increasing[SIM_STEPS_SIG_CHANGING-1-i] ;
    }

    printf("\n%s%f\n", "MPR sig_decreasing[0]: ", MPR_sig_decreasing[0]);
    printf("\n%s%f\n","MPR sig_decreasing[last]: ", MPR_sig_decreasing[SIM_STEPS_SIG_CHANGING-1]);

    // create a vector of MPR signals for pampas: 
    for(i=0; i<SIM_STEPS_SIG_LO_CONSTANT;i++){
         MPR_sig_lo_constant[i] = MPR_sig_decreasing[SIM_STEPS_SIG_CHANGING-1];
    }

    printf("\n%s%f\n", "MPR sig_lo_constant[0]: ", MPR_sig_lo_constant[0]);
    printf("\n%s%f\n","MPR sig_lo_constant[last]: ", MPR_sig_lo_constant[SIM_STEPS_SIG_LO_CONSTANT-1]);

    // Write the MPR signal trajectory to the file:
    save_mpr_traj_sstate(fh_MPR, MODEL_NO, MPR_sig_increasing, SIM_STEPS_SIG_CHANGING);
    save_mpr_traj_sstate(fh_MPR, MODEL_NO, MPR_sig_hi_constant, SIM_STEPS_SIG_HI_CONSTANT);
    save_mpr_traj_sstate(fh_MPR, MODEL_NO, MPR_sig_decreasing, SIM_STEPS_SIG_CHANGING);
    save_mpr_traj_sstate(fh_MPR, MODEL_NO, MPR_sig_lo_constant, SIM_STEPS_SIG_LO_CONSTANT);
    fclose(fh_MPR); 

   // Copy MPR to local variable
    for (i=0;i<NUM_NODES;++i) {
        MPR_arr[i]=MPR_arrv[i];
    } 

    read_config(WORK_DIR,fname_cfg);

    // Calculate minimum and maximum allowable expression for each node:
    cal_EXPrange(NUM_NODES,NUM_EDGES,MPR_arr,DNR_arrv,\
                 edge_source_arrv, edge_target_arrv,\
                 edge_type_arrv, FCH_arrv, minEXP_arr, maxEXP_arr);
    
    // 1. Allocate memory to save the trajectory: 
    TRAJ_exp_arr=allocate_LCmemory(NO_MEM_SLOTS, NUM_NODES);

    // 2. Set trajectory start expressions variable from the parameter:
    // (0th position of the array is used)
    for (i=0;i<NUM_NODES;++i) {
        TRAJ_start_exp_arr[i]=std_st_exp_arrv[i];
        TRAJ_exp_arr[0][i]=std_st_exp_arrv[i];
    }

    printf("\n%s%f\n", "MPR at time 0: ", MPR_arr[SIGNALING_NODE_ID]);
    printf("%s%f\n","Start exp at time 0: ", TRAJ_start_exp_arr[SIGNALING_NODE_ID]);

    fprintf(fh_MPR,"%d\t", MODEL_NO);
    fprintf(fh_MPR,"%10.6f\n", MPR_arr[SIGNALING_NODE_ID]);
    fflush(fh_MPR);

    // 3. Time interval: T1 - simulation as increasing signal
    // positions used: 1 ~ SIMSTEPS_SIG_INCREASING 
    cal_trajectory(NUM_NODES,NUM_EDGES,\
                   SIM_STEPS_SIG_CHANGING,\
                   TRAJ_SIM_STEP_SIZE,\
                   CONVERGENCE_PROXIMITY,\
                   TRANS_RATE_FACTOR,\
                   MPR_arr,\
                   DNR_arrv,\
                   node_type_arrv,\
                   edge_source_arrv,\
                   edge_target_arrv,\
                   edge_type_arrv,\
                   TSH_arrv,\
                   HCO_arrv,\
                   FCH_arrv,\
                   SIGNALING_NODE_ID,\
                   MPR_sig_increasing,\
                   TRAJ_start_exp_arr,\
                   TRAJ_exp_arr+1);

    // 4. Time interval: T2 - relaxation after t1
    // Set start expressions: 
    for (i=0;i<NUM_NODES;++i) {
        TRAJ_start_exp_arr[i]=TRAJ_exp_arr[SIM_STEPS_SIG_CHANGING][i];
    }

    printf("\n%s%f\n", "MPR at time t1: ", MPR_arr[SIGNALING_NODE_ID]);
    printf("%s%f\n","Start exp at time t1: ", TRAJ_start_exp_arr[SIGNALING_NODE_ID]);

    // Calculate trajectory:
    cal_trajectory(NUM_NODES,NUM_EDGES,\
                   SIM_STEPS_SIG_HI_CONSTANT,\
                   TRAJ_SIM_STEP_SIZE,\
                   CONVERGENCE_PROXIMITY,\
                   TRANS_RATE_FACTOR,\
                   MPR_arr,\
                   DNR_arrv,\
                   node_type_arrv,\
                   edge_source_arrv,\
                   edge_target_arrv,\
                   edge_type_arrv,\
                   TSH_arrv,\
                   HCO_arrv,\
                   FCH_arrv,\
                   SIGNALING_NODE_ID,\
                   MPR_sig_hi_constant,\
                   TRAJ_start_exp_arr,\
                   TRAJ_exp_arr+1+SIM_STEPS_SIG_CHANGING);

    // 5. Time interval: T3 - signal decreasing
    // Set start expressions:
    for (i=0;i<NUM_NODES;++i) {
        TRAJ_start_exp_arr[i]=TRAJ_exp_arr[SIM_STEPS_SIG_CHANGING+SIM_STEPS_SIG_HI_CONSTANT][i];
    }

    printf("\n%s%f\n", "MPR at time t2: ", MPR_arr[SIGNALING_NODE_ID]);
    printf("%s%f\n","Start exp at time t2: ", TRAJ_start_exp_arr[SIGNALING_NODE_ID]);

    // Calculate trajectory:
    cal_trajectory(NUM_NODES,NUM_EDGES,\
                   SIM_STEPS_SIG_CHANGING,\
                   TRAJ_SIM_STEP_SIZE,\
                   CONVERGENCE_PROXIMITY,\
                   TRANS_RATE_FACTOR,\
                   MPR_arr,\
                   DNR_arrv,\
                   node_type_arrv,\
                   edge_source_arrv,\
                   edge_target_arrv,\
                   edge_type_arrv,\
                   TSH_arrv,\
                   HCO_arrv,\
                   FCH_arrv,\
                   SIGNALING_NODE_ID,\
                   MPR_sig_decreasing,\
                   TRAJ_start_exp_arr,\
                   TRAJ_exp_arr+1+SIM_STEPS_SIG_CHANGING+
                                  SIM_STEPS_SIG_HI_CONSTANT);

    printf("\n%s%f\n", "MPR at time t3: ", MPR_arr[SIGNALING_NODE_ID]);

    // 6. Time Interval T4: relaxation at the end  
    // Set start expressions:
    for (i=0;i<NUM_NODES;++i) {
        TRAJ_start_exp_arr[i]=TRAJ_exp_arr[SIM_STEPS_SIG_CHANGING+\
                                           SIM_STEPS_SIG_HI_CONSTANT+\
                                           SIM_STEPS_SIG_CHANGING][i];
    }

    // Calculate trajectory:
    cal_trajectory(NUM_NODES,NUM_EDGES,\
                   SIM_STEPS_SIG_LO_CONSTANT,\
                   TRAJ_SIM_STEP_SIZE,\
                   CONVERGENCE_PROXIMITY,\
                   TRANS_RATE_FACTOR,\
                   MPR_arr,\
                   DNR_arrv,\
                   node_type_arrv,\
                   edge_source_arrv,\
                   edge_target_arrv,\
                   edge_type_arrv,\
                   TSH_arrv,\
                   HCO_arrv,\
                   FCH_arrv,\
                   SIGNALING_NODE_ID,\
                   MPR_sig_lo_constant,\
                   TRAJ_start_exp_arr,\
                   TRAJ_exp_arr+1+SIM_STEPS_SIG_CHANGING+\
                                  SIM_STEPS_SIG_HI_CONSTANT+\
                                  SIM_STEPS_SIG_CHANGING);

    printf("\n%s%f\n", "MPR at time t4: ", MPR_arr[SIGNALING_NODE_ID]);


    //save_mpr_at_traj_end(fh_MPR, MODEL_NO, \
    //                      SIGNALING_NODE_ID,\
    //                      MPR_arr);
    
    //6. write the trajectory to the file: 
    /*
    save_expr_traj_sstate(fh_STATES, MODEL_NO, NUM_NODES,\
                         NO_MEM_SLOTS, TRAJ_exp_arr); 
    */
    //save_expr_traj_spoints_sstate(fh_STATES, MODEL_NO, NUM_NODES,\
    //                              NO_MEM_SLOTS, TRAJ_exp_arr); 
    save_expr_traj_spoints_sstate(fh_STATES, MODEL_NO, NUM_NODES,\
                                  NO_MEM_SLOTS, TRAJ_exp_arr, \
                                  SAMPLING_DIST); 

    //7. free the memory allocated for trajectory:
    free_LCmemory(TRAJ_exp_arr, NO_MEM_SLOTS , NUM_NODES);
    return;
}

/*-----------------------------------------------------------------------*/
void cal_trajectory(int NUM_NODES,int NUM_EDGES,\
                    int SIM_STEPS,\
                    double SIM_STEP_SIZE,\
                    long double CONVERGENCE_PROXIMITY,\
                    double TRANS_RATE_FACTOR,\
                    double *MPR_arrv,\
                    const double *DNR_arrv,\
                    const int *node_type_arrv,\
                    const int *edge_source_arrv,\
                    const int *edge_target_arrv,\
                    const int *edge_type_arrv,\
                    const double *TSH_arrv,\
                    const int *HCO_arrv,\
                    const double *FCH_arrv,\
                    const int SIGNALING_NODE_ID,\
                    double *MPR_along_traj,\
                    double *start_exp_arr,\
                    double **TRAJ_exp_arr)
{
    double fX_arr[NUM_NODES]; //fX_arr saves fX values in each Euler step
    double curr_exp_arr[NUM_NODES];
    double next_exp_arr[NUM_NODES];
    int i;

    //Copy the start expressions to a local variable:
    for (i=0;i<NUM_NODES;++i) {
        curr_exp_arr[i]=start_exp_arr[i]; 
    }

    int count_step=0;
    while(count_step<SIM_STEPS)
    {
        MPR_arrv[SIGNALING_NODE_ID]=MPR_along_traj[count_step];

        cal_fX(NUM_NODES,NUM_EDGES,SIM_STEP_SIZE,\
               TRANS_RATE_FACTOR,\
               MPR_arrv,\
               DNR_arrv,\
               node_type_arrv,edge_source_arrv,\
               edge_target_arrv,edge_type_arrv,\
               TSH_arrv,HCO_arrv,FCH_arrv,\
               curr_exp_arr,fX_arr);
        
        //Calculate next expressions:
        for (i=0;i<NUM_NODES;++i) {
             next_exp_arr[i]=curr_exp_arr[i]+fX_arr[i]*SIM_STEP_SIZE;
        }

        //copy next exp to curr exp and save curr exp
        for (i=0;i<NUM_NODES;++i){
            curr_exp_arr[i]=next_exp_arr[i]>=0?next_exp_arr[i]:0;
            TRAJ_exp_arr[count_step][i]=curr_exp_arr[i];
        }

        //Update step counter:
        count_step+=1;
    }
    return ;
}

/*-----------------------------------------------------------------------*/
void save_mpr_traj_sstate(FILE *fh_MPR, int MODEL_NO, \
                    double *MPR_traj, int MPR_traj_size)
{ 
    int i;
    //writes MPR trajectory of some node
    for(i=0; i<MPR_traj_size; i++){
         fprintf(fh_MPR,"%d\t",MODEL_NO);
         fprintf(fh_MPR,"%10.6f\n",MPR_traj[i]);
    }
    fflush(fh_MPR);
    return;
}

/*-----------------------------------------------------------------------*/
void save_mpr_at_traj_end(FILE *fh_MPR, int MODEL_NO, int SIGNALING_NODE_ID,\
                           double *MPR_arr)
{ 
    //This function writes the expressions of the network states 
    //along a trajectory.
    int j; //outer loop counter
    int k; //inner loop coutner

    fprintf(fh_MPR,"%d\t",MODEL_NO);
    fprintf(fh_MPR,"%10.6f\n",MPR_arr[SIGNALING_NODE_ID]);
    fflush(fh_MPR);
    return;
}

/*-----------------------------------------------------------------------*/
void save_expr_traj_sstate(FILE *fh_TRAJ, int MODEL_NO, int NUM_NODES,\
                          int TRAJ_SIZE, double **TRAJ_exp_arr)
{ 
    //This function writes the expressions of the network states 
    //along a trajectory.
    int j; //outer loop counter
    int k; //inner loop coutner

    for (j=0;j<TRAJ_SIZE;j++){
       fprintf(fh_TRAJ,"%d\t",MODEL_NO);
       fprintf(fh_TRAJ,"%d\t",MODEL_NO);
       fprintf(fh_TRAJ,"%d\t",MODEL_NO);

       //write limit cycle number:
         for(k=0;k<NUM_NODES;k++){ 
            //save log2(gene expression):
            fprintf(fh_TRAJ,"%10.6f\t",log(TRAJ_exp_arr[j][k])/log(2));
         }
         //new line to separate the expressions from
         //those of the next time step:
         fprintf(fh_TRAJ,"%s","\n");
    }
    //new line after writing the whole LC
    //this separates expressions between limit cycles:
    fprintf(fh_TRAJ,"%s","\n");
    fflush(fh_TRAJ);
    return;
}

/*-----------------------------------------------------------------------*/
void save_expr_traj_spoints_sstate(FILE *fh_TRAJ, int MODEL_NO, int NUM_NODES,\
                                   int TRAJ_SIZE, double **TRAJ_exp_arr, 
                                   int SAMPLING_DIST)
{ 
    //This function writes the expressions of the network states 
    //along a trajectory: sampled points along the trajectory
    int j; //outer loop counter
    int k; //inner loop coutner
    //const int SAMPLING_DIST=500;

    for (j=0;j<TRAJ_SIZE;j++){
       if(!(j%SAMPLING_DIST)){
       fprintf(fh_TRAJ,"%d\t",MODEL_NO);
       fprintf(fh_TRAJ,"%d\t",MODEL_NO);
       fprintf(fh_TRAJ,"%d\t",MODEL_NO);

       //write limit cycle number:
         for(k=0;k<NUM_NODES;k++){ 
            //save log2(gene expression):
            fprintf(fh_TRAJ,"%10.6f\t",log(TRAJ_exp_arr[j][k])/log(2));
         }
         //new line to separate the expressions from
         //those of the next time step:
         fprintf(fh_TRAJ,"%s","\n");
       }
    }
    //new line after writing the whole LC
    //this separates expressions between limit cycles:
    fprintf(fh_TRAJ,"%s","\n");
    fflush(fh_TRAJ);
    return;
}

/*-----------------------------------------------------------------------*/
void cluster_solutions(char *WORK_DIR, \
                       char *FNAME_STATES, char *FNAME_LIMITCYCLES, \
                       char *FNAME_SUMMARY,\
                       const int MODEL_NO,\
                       int NUM_NODES,int NUM_EDGES,\
                       int NUM_RANDOM_ICS,int ITER_FOR_ODE,\
                       double EULER_SIM_TIME,\
                       double EULER_STEP_SIZE,\
                       long double CONVERGENCE_PROXIMITY,\
                       double TRANS_RATE_FACTOR,\
                       const double *MPR_arrv,\
                       const double *DNR_arrv,\
                       const int *node_type_arrv,\
                       const int *edge_source_arrv,\
                       const int *edge_target_arrv,\
                       const int *edge_type_arrv,\
                       const double *TSH_arrv,\
                       const int *HCO_arrv,\
                       const double *FCH_arrv,\
                       double *fX_arr_norm,\
                       double EXP_arr[][NUM_NODES])
/*------------------------------------------------------------------
This function clusters the solutions obtained from all initial 
conditions into states and limit cycles.

It invokes two functions to carry out its operation:  
  (1) find_states: clusters all the solutions into states
  (2) find_limitcycles: for each solution not used in state calculation,
      this function runs further simulation to obtain the limit cycle
      for that solution.
--------------------------------------------------------------------*/
{
    //LOCAL VARIABLES:
    //variables for limit cycle (LC) calculation:
    bool fX_arr_bool[NUM_RANDOM_ICS];

    //COUNTING VARIABLES:
    int state_count;
    int LC_count;
    int i;

    clock_t time_begin, time_end; 
    double time_spent; 

    //DEFINE FILE NAME:
    //char fname_summary[300]="\0";
    //strcat(fname_summary,WORK_DIR);
    //strcat(fname_summary,"/");
    //strcat(fname_summary,"cellcycle.summary.txt");
    //strcat(fname_summary,"TS.summary.txt");

    state_count=0; 
    LC_count=0; 

    state_count=find_states(WORK_DIR, FNAME_STATES, MODEL_NO,\
                            NUM_NODES, NUM_RANDOM_ICS,\
                            CONVERGENCE_PROXIMITY,\
                            fX_arr_norm,\
                            EXP_arr,\
                            fX_arr_bool);

    time_begin=clock(); 
    LC_count=find_limitcycles(WORK_DIR, FNAME_LIMITCYCLES, MODEL_NO,\
                              NUM_NODES,NUM_EDGES,\
                              NUM_RANDOM_ICS,ITER_FOR_ODE,\
                              EULER_SIM_TIME,\
                              EULER_STEP_SIZE,\
                              CONVERGENCE_PROXIMITY,\
                              TRANS_RATE_FACTOR,\
                              MPR_arrv,\
                              DNR_arrv,\
                              node_type_arrv,\
                              edge_source_arrv,\
                              edge_target_arrv,\
                              edge_type_arrv,\
                              TSH_arrv,\
                              HCO_arrv,\
                              FCH_arrv,\
                              fX_arr_norm,\
                              EXP_arr,\
                              fX_arr_bool);

    time_end=clock();
    time_spent=(double) (time_end-time_begin)/CLOCKS_PER_SEC;
    //write summary:
    FILE *fh_summary;
    //fh_summary=fopen(fname_summary,"a");
    fh_summary=fopen(FNAME_SUMMARY,"a");
    fprintf(fh_summary,"%d\t%d\t%d\t%8.6f\n",MODEL_NO, state_count,\
                                              LC_count,time_spent);
    fflush(fh_summary);
    fclose(fh_summary); 
    return;
}

/*-----------------------------------------------------------------------*/
int find_states(char *WORK_DIR, char *FNAME_STATES, \
                const int MODEL_NO,\
                int NUM_NODES, int NUM_RANDOM_ICS,\
                long double CONVERGENCE_PROXIMITY,\
                double *fX_arr_norm,\
                double EXP_arr[][NUM_NODES],\
                bool fX_arr_bool[NUM_RANDOM_ICS])
{
    //LOCAL VARIABLES:
    int MAX_STABLE_STATES=sim_config.MAX_STABLE_STATES;
    //solution_count_arr stores the number of solutions in each state:
    int solution_count_arr[MAX_STABLE_STATES];
    //solution_arr stores the average expression for all states: 
    double solution_arr[MAX_STABLE_STATES][NUM_NODES];
    //solution_arr_avg stores the average solution for any state:
    double solution_arr_avg[NUM_NODES];

    double testDelta=0.0;
    bool found;

    //COUNTING VARIABLES:
    int count_state;
    int i;

    //DEFINE FILE NAME:
    //char fname_states[300]="\0";
    //strcat(fname_states,WORK_DIR);
    //strcat(fname_states,"/");
    //strcat(fname_states,"cellcycle.states.txt");
    //strcat(fname_states,"TS.states.txt");

    //initialize the solution count for each state: 
    for (i=0;i<MAX_STABLE_STATES;i++) solution_count_arr[i]=0; 

    //SEPARATE ALL THE STABLE STATES INTO CLUSTERS:
    count_state=0; //initialize state count variable
    for (i=0;i<NUM_RANDOM_ICS;i++)
    {
        if (fX_arr_norm[i]>CONVERGENCE_PROXIMITY)
        {
             fX_arr_bool[i]=true; 
             continue;
        }
        fX_arr_bool[i]=false; 
        found = false;
        int sol_no;
        for (sol_no=0; sol_no<count_state;sol_no++)
        {
            testDelta=sum_delta(solution_arr[sol_no],EXP_arr[i],NUM_NODES);
            if (testDelta<=CONVERGENCE_PROXIMITY)
            {
		         int j;
                for(j=0;j<NUM_NODES;j++)
                {
                    solution_arr[sol_no][j]=(solution_arr[sol_no][j]*\
                                             solution_count_arr[sol_no]+\
                                             EXP_arr[i][j])/\
                                             (solution_count_arr[sol_no]+1);
                }
		          solution_count_arr[sol_no]++;
		          found=true;
                break;
             }
         }
         //new solution found:
         if(!found){
        		  int j;
              for (j=0;j<NUM_NODES;j++) {
                  solution_arr[count_state][j]=EXP_arr[i][j]; 
              }
              //printf("fX_arr_norm[i]: %d\t%f\n",count_state,fX_arr_norm[i]);
	           solution_count_arr[count_state]=1;
	           count_state+=1; 
              if(count_state>=MAX_STABLE_STATES) break; 
         }
    }

    //SAVE SOLUTIONS: solution_arr
    FILE *fh_states;
    fh_states=fopen(FNAME_STATES,"a");
    int j;
    int k;

    //write a new line to move the file pointer to the next line 
    //fprintf(fh_states,"\n");  
    for (j=0; j<count_state;j++){
         fprintf(fh_states,"%d\t",MODEL_NO);  //write model index
         fprintf(fh_states,"%d\t",count_state); //write total solution
         fprintf(fh_states,"%d\t",(j+1));     //write solution index
         for(k=0;k<NUM_NODES;k++){            //write gene levels 
             fprintf(fh_states,"%10.6f\t",log(solution_arr[j][k])/log(2));
         }
         fprintf(fh_states,"\n");
    }

    fflush(fh_states);
    fclose(fh_states);
    return count_state;
}

/*-----------------------------------------------------------------------*/
int find_limitcycles(char *WORK_DIR, char *FNAME_LIMITCYCLES, \
                     const int MODEL_NO,\
                     int NUM_NODES, int NUM_EDGES,\
                     int NUM_RANDOM_ICS, int ITER_FOR_ODE,\
                     double EULER_SIM_TIME,\
                     double EULER_STEP_SIZE,\
                     long double CONVERGENCE_PROXIMITY,\
                     double TRANS_RATE_FACTOR,\
                     const double *MPR_arrv,\
                     const double *DNR_arrv,\
                     const int *node_type_arrv,\
                     const int *edge_source_arrv,\
                     const int *edge_target_arrv,\
                     const int *edge_type_arrv,\
                     const double *TSH_arrv,\
                     const int *HCO_arrv,\
                     const double *FCH_arrv,\
                     double *fX_arr_norm,\
                     double EXP_arr[][NUM_NODES],\
                     bool fX_arr_bool[NUM_RANDOM_ICS])
/*------------------------------------------------------------------
This function finds and saves limit cycles. It calls other functions
to carry these out:
   (1) detect_limitcycle: this returns the estimated size of 
      the limit cycle.
   (2) cal_limitcycle: this calculates expression levels along the 
       limit cycle.
    return value: number of limit cycle found for a specific model.
--------------------------------------------------------------------*/
{
    //CONSTANTS:
    const double LIMIT_CYCLE_SIM_TIME=sim_config.LIMIT_CYCLE_SIM_TIME;
    const double LIMIT_CYCLE_SIM_STEP_SIZE=sim_config.LIMIT_CYCLE_SIM_STEP_SIZE;
    const int LIMIT_CYCLE_SIM_STEPS=(int) (LIMIT_CYCLE_SIM_TIME/\
                                           LIMIT_CYCLE_SIM_STEP_SIZE);
    const int MAX_LIMIT_CYCLES=sim_config.MAX_LIMIT_CYCLES;
    const int ALLOWED_ERROR_IN_PERIODS=sim_config.ALLOWED_ERROR_IN_PERIODS;

    //LOCAL VARIABLES:
    int LC_period_arr[MAX_LIMIT_CYCLES];
    double **LC_exp_arr;

    double start_exp_arr[NUM_NODES]; //start point for calculating limit cycle
    double LC_start_exp_arr[NUM_NODES];

    int period=0; //period of the limit cycle

    //COUNTING VARIABLE:
    int count_LC;
    int i;

    //DEFINE FILE HEADER:
    FILE *fh_LCs;
    //fh_LCs=fopen(fname_LCs,"a");
    fh_LCs=fopen(FNAME_LIMITCYCLES,"a");

    //write a new line to move the file pointer to the next line 
    //fprintf(fh_LCs,"\n");  

    //initialize LC_period_arr with zeros:
    for (i=0;i<MAX_LIMIT_CYCLES;i++){
        LC_period_arr[i]=0; 
    }

    //initialize LC_start_exp_arr
    //it will be defined in detect_limitcycle()
    for (i=0;i<NUM_NODES;i++){
       LC_start_exp_arr[i]=0.0;
    }

    //initialize limit cycle count variable:
    count_LC=0;
    for (i=0;i<NUM_RANDOM_ICS;i++)
    {
	      if (fX_arr_bool[i]==false) continue;

         //calculate limit cycle:
	      fX_arr_bool[i]=false;
         period=detect_limitcycle(NUM_NODES,NUM_EDGES,\
                                  LIMIT_CYCLE_SIM_STEPS,\
                                  LIMIT_CYCLE_SIM_STEP_SIZE,\
                                  CONVERGENCE_PROXIMITY,\
                                  TRANS_RATE_FACTOR,\
                                  MPR_arrv,DNR_arrv,\
                                  node_type_arrv,\
                                  edge_source_arrv,\
                                  edge_target_arrv,\
                                  edge_type_arrv,\
                                  TSH_arrv,\
                                  HCO_arrv,\
                                  FCH_arrv,\
                                  EXP_arr[i],\
                                  LC_start_exp_arr);

        if(period>0){
             //check for repeated limit cycle:
             int j;
             int k;
             //NEW_SIM_STEPS: simulation steps for calculating expression 
             //levels along limit cycle:
             int NEW_SIM_STEPS;

             //MAX_DIST: used as an allowed error between the converged expression 
             //levels (based on Initial Conditions) and the expression 
             //level along the limit cycle:
             double MAX_DIST; 
             double tmp_norm=0.0;
             bool is_same;

             is_same=false;
             for(k=0;k<count_LC;k++){
                  if(abs(period-LC_period_arr[k])<=ALLOWED_ERROR_IN_PERIODS){
                     is_same=true;
                     break;
                  }
             }
             //if it is the same limit cycle, skip subsequent calculation:
             if(is_same) continue;

             LC_period_arr[count_LC]=period;
             count_LC++;
             LC_exp_arr=allocate_LCmemory(period+2,NUM_NODES);
             NEW_SIM_STEPS=period+1;

             MAX_DIST=cal_limitcycle(NUM_NODES,NUM_EDGES,\
                                     NEW_SIM_STEPS,\
                                     LIMIT_CYCLE_SIM_STEP_SIZE,\
                                     CONVERGENCE_PROXIMITY,\
                                     TRANS_RATE_FACTOR,\
                                     MPR_arrv,DNR_arrv,\
                                     node_type_arrv,\
                                     edge_source_arrv,\
                                     edge_target_arrv,\
                                     edge_type_arrv,\
                                     TSH_arrv,\
                                     HCO_arrv,\
                                     FCH_arrv,\
                                     LC_start_exp_arr,\
                                     LC_exp_arr);

             //relax MAX_DIST by factoring it by 10:
             MAX_DIST *= 10.0;

             //change fX_arr_bool status to false for all the positions that 
             //all give to this limit cycle:
             for (j=0;j<NUM_RANDOM_ICS;j++){
	             if (fX_arr_bool[j]==false) continue;
                for(k=0;k<period+2;k++){
                     tmp_norm=sum_delta(EXP_arr[j],LC_exp_arr[k],NUM_NODES);
                     if(tmp_norm<=MAX_DIST) {
	                     fX_arr_bool[j]=false;
                        break;
                     }
                }
             }
            
             //write LC expressions to file: 
             write_limitcycle(fh_LCs, MODEL_NO, NUM_NODES,\
                              count_LC, period, NEW_SIM_STEPS,\
                              LC_exp_arr);
             //note: NEW_SIM_STEPS is larger than period by 2

             //free the memory allocated for the current LC: 
             free_LCmemory(LC_exp_arr,period+2,NUM_NODES);
             if(count_LC>=MAX_LIMIT_CYCLES) break;
        }
    }
    fflush(fh_LCs);
    fclose(fh_LCs); 
    return count_LC;
}

/*-----------------------------------------------------------------------*/
int detect_limitcycle(int NUM_NODES,int NUM_EDGES,\
                      int SIM_STEPS,double SIM_STEP_SIZE,\
                      long double CONVERGENCE_PROXIMITY,\
                      double TRANS_RATE_FACTOR,\
                      const double *MPR_arrv,const double *DNR_arrv,\
                      const int *node_type_arrv,\
                      const int *edge_source_arrv,\
                      const int *edge_target_arrv,\
                      const int *edge_type_arrv,\
                      const double *TSH_arrv,\
                      const int *HCO_arrv,\
                      const double *FCH_arrv,\
                      double *start_exp_arr,\
                      double *LC_start_exp_arr)
{
    //CONSTANTS:
    const int ITER_FOR_LIMIT_CYCLE=sim_config.ITER_FOR_LIMIT_CYCLE;
    const int MAX_PERIODS=sim_config.MAX_ALLOWED_PERIODS;

    //variables:
    double fX_arr[NUM_NODES]; //fX_arr saves fX values in each Euler step
    double prev_exp_arr[NUM_NODES]; 
    double curr_exp_arr[NUM_NODES];
    double next_exp_arr[NUM_NODES];
    int i;

    //storage for expressions at each peak:
    double max_exp_arr[MAX_PERIODS][NUM_NODES];
    //storage for expressions at each valley:
    double min_exp_arr[MAX_PERIODS][NUM_NODES];
    //storage for index at each peak:
    int max_idx_arr[MAX_PERIODS];
    //storage for index at each valley:
    int min_idx_arr[MAX_PERIODS];
    //store for distances from the start to each valley:
    double min_dist_arr[MAX_PERIODS];

    //storage for differences between min_dist and prev_dist:
    //double diff_dist_arr[MAX_PERIODS];
    
    //counts for peaks and valleys:
    int count_max_exp, count_min_exp;
    
    double prev_dist, curr_dist; //keeps track of distance from the start
    bool moving_uphill; //keeps track of simulation direction

    int count_exp; //global count for simulation steps
    int period; //period for the LC
    int count_iter; //count for the outer loop

    //copy the start expressions to a local variable:
    for (i=0;i<NUM_NODES;++i) {
        curr_exp_arr[i]=start_exp_arr[i]; 
        prev_exp_arr[i]=curr_exp_arr[i]; 
        //printf("%2.6f\t",curr_exp_arr[i]);
    }
    
    //initialize the control variables:
    prev_dist=curr_dist=0.0;
    moving_uphill=true;
    count_exp=0;
    count_max_exp=count_min_exp=0;
    period=0;

    //calculate ODE-outer loop:
    for(count_iter=0; count_iter<ITER_FOR_LIMIT_CYCLE;count_iter++) 
    {
        //calculate ODE-inner loop:
        int count_step=0;
        while(count_step<SIM_STEPS)
        {
            cal_fX(NUM_NODES,NUM_EDGES,SIM_STEP_SIZE,\
                   TRANS_RATE_FACTOR,\
                   MPR_arrv,DNR_arrv,\
                   node_type_arrv,edge_source_arrv,\
                   edge_target_arrv,edge_type_arrv,\
                   TSH_arrv,HCO_arrv,FCH_arrv,\
                   curr_exp_arr,fX_arr);
            //calculate next expressions:
            for (i=0;i<NUM_NODES;++i) {
                 next_exp_arr[i]=curr_exp_arr[i]+fX_arr[i]*SIM_STEP_SIZE;
            }
 
            curr_dist=sum_delta(start_exp_arr,next_exp_arr,NUM_NODES);
            if(moving_uphill){ //while moving uphill:
                if (curr_dist<prev_dist){
                    //hit the peak already. now, switch to downhill:
                    moving_uphill=false;
                }
            }
            else { //while moving downhill:
                if (curr_dist>prev_dist){
                    //hit the bottom already. now, switch to uphill:
                    moving_uphill=true;
                    //save information about this valley:
                    for (i=0;i<NUM_NODES;++i){
                        min_exp_arr[count_min_exp][i]=curr_exp_arr[i];
                    }
                    min_idx_arr[count_min_exp]=count_exp;
                    min_dist_arr[count_min_exp]=prev_dist;
                    //diff_dist_arr[count_min_exp]=sum_delta(curr_exp_arr,\
                    //                                       next_exp_arr,\
                    //                                       NUM_NODES);
                    count_min_exp++;
                } //(curr_dist>prev_dist)
            } //end of the block for moving downhill

            if((count_max_exp>=MAX_PERIODS) ||
               (count_min_exp>=MAX_PERIODS)) break;
             
            prev_dist=curr_dist; //uphill motion
            //copy next exp to curr exp and save curr exp
            for (i=0;i<NUM_NODES;++i){
                curr_exp_arr[i]=next_exp_arr[i]>=0?next_exp_arr[i]:0;
            }
            count_exp++;
            count_step+=1;
        } //end of while(count_step<SIM_STEPS)

        double fX_norm=cal_norm(fX_arr,NUM_NODES);
        //if a stable state is found or a boundary situation is met,
        //then return -1:
        if(fX_norm<=CONVERGENCE_PROXIMITY) return -1;

        period=cal_period(NUM_NODES,\
                          MAX_PERIODS,\
                          count_min_exp,\
                          min_idx_arr,\
                          min_exp_arr,\
                          LC_start_exp_arr);
        //if nonzero period found, then break of the loop:
        if (period!=0) break;
    }//for(count_iter=0; count_iter<ITER_FOR_LIMIT_CYCLE;count_iter++)

    return period;
} 

/*-----------------------------------------------------------------------*/
int cal_period(int NUM_NODES,\
               int MAX_PERIODS,\
               int count_min_exp,\
               int *min_idx_arr,\
               double min_exp_arr[][NUM_NODES],\
               double *LC_start_exp_arr)
{
    //CALCULATE PERIODS from all valleys 
    //CONSTANTS:
    const int NO_OF_SAMPLED_PERIODS=sim_config.NO_OF_SAMPLED_PERIODS;
    const int ALLOWED_ERROR_IN_PERIODS=sim_config.ALLOWED_ERROR_IN_PERIODS;
    const double SAMEPOINT_PROXIMITY=sim_config.SAMEPOINT_PROXIMITY;

    //LOCAL VARIABLES:
    int period;
    int count_same_min_dist;
    int count_period; //counts number of periods found
    int period_T[MAX_PERIODS]; //saves the periods
    int idx_last_period; //keeps track of the index of the last period
    double diff_exp; //saves diff between expr levels at two time points
    bool found = false; //marks whether period is found

    int i;

    //initialize all variables:
    period=0;
    count_period=0; 
    diff_exp=0.0; 
    count_same_min_dist=0;   
    //set a marker at the index of the position of the last valley:
    idx_last_period=count_min_exp-1; 

    //check in backward direction starting from
    //the last element in min_dist_arr:
    for (i=count_min_exp-2;i>=0;i--){
       diff_exp=sum_delta(min_exp_arr[count_min_exp-1],\
                          min_exp_arr[i],NUM_NODES);
       if(diff_exp<=SAMEPOINT_PROXIMITY){
          count_same_min_dist++;
          period_T[count_period]=min_idx_arr[idx_last_period]-min_idx_arr[i];
          //save position of the valley where the last period was found:
          idx_last_period=i;
          count_period++; //increment count of the periods found
       }
    }
    if(count_period>=NO_OF_SAMPLED_PERIODS){
        found = true;
        //check whether each of these periods is 
        //within the allowed error limit:
        for (i=count_period-1;i>=1;i--){
            if(abs(period_T[i]-period_T[i-1])>ALLOWED_ERROR_IN_PERIODS){
                found = false;
                break;
            }
        }
    }
    if(found){
        //copy the last sampled period to period varialbe for returning:
        period=period_T[count_period-1];
        //copy the last minimum expression to the 
        //LC start variable for returning:
        for(i=0;i<NUM_NODES;i++){
           LC_start_exp_arr[i]=min_exp_arr[count_min_exp-1][i];
        }
    }
    return period;
}

/*-----------------------------------------------------------------------*/
double cal_limitcycle(int NUM_NODES,int NUM_EDGES,\
                      int SIM_STEPS,double SIM_STEP_SIZE,\
                      long double CONVERGENCE_PROXIMITY,\
                      double TRANS_RATE_FACTOR,\
                      const double *MPR_arrv,const double *DNR_arrv,\
                      const int *node_type_arrv,\
                      const int *edge_source_arrv,\
                      const int *edge_target_arrv,\
                      const int *edge_type_arrv,\
                      const double *TSH_arrv,\
                      const int *HCO_arrv,\
                      const double *FCH_arrv,\
                      double *start_exp_arr,\
                      double **LC_exp_arr)
{

    double fX_arr[NUM_NODES]; //fX_arr saves fX values in each Euler step
    double curr_exp_arr[NUM_NODES];
    double next_exp_arr[NUM_NODES];
    int i;
    double max_dist;
    //copy the start expressions to a local variable:
    for (i=0;i<NUM_NODES;++i) {
        curr_exp_arr[i]=start_exp_arr[i]; 
        LC_exp_arr[0][i]=curr_exp_arr[i];
    }

    int count_step=0;
    max_dist=0.0;
    while(count_step<SIM_STEPS)
    {
        cal_fX(NUM_NODES,NUM_EDGES,SIM_STEP_SIZE,\
               TRANS_RATE_FACTOR,\
               MPR_arrv,DNR_arrv,\
               node_type_arrv,edge_source_arrv,\
               edge_target_arrv,edge_type_arrv,\
               TSH_arrv,HCO_arrv,FCH_arrv,\
               curr_exp_arr,fX_arr);
        //calculate next expressions:
        for (i=0;i<NUM_NODES;++i) {
             next_exp_arr[i]=curr_exp_arr[i]+fX_arr[i]*SIM_STEP_SIZE;
        }

        double tmp_dist;
        tmp_dist=sum_delta(curr_exp_arr,next_exp_arr,NUM_NODES);
        if(tmp_dist>max_dist) max_dist=tmp_dist;

        count_step+=1;
        //copy next exp to curr exp and save curr exp
        for (i=0;i<NUM_NODES;++i){
            curr_exp_arr[i]=next_exp_arr[i]>=0?next_exp_arr[i]:0;
            LC_exp_arr[count_step][i]=curr_exp_arr[i];
        }
   }
   //printf("%f\n",max_dist);
   return max_dist;
}

/*-----------------------------------------------------------------------*/
void write_limitcycle(FILE *fh_LCs, int MODEL_NO, int NUM_NODES,\
                      int count_LC, int SIZE_OF_PERIOD, int SIZE_OF_LIMIT_CYCLE,\
                      double **LC_exp_arr)
{ 
    //This function writes the expressions of the network states 
    //along the limit cycle.
    int j; //outer loop counter
    int k; //inner loop coutner

    //for (j=0;j<NEW_SIM_STEPS+1;j++){
    for (j=0;j<SIZE_OF_LIMIT_CYCLE+1;j++){
       fprintf(fh_LCs,"%d\t",MODEL_NO);
       //write limit cycle number:
       fprintf(fh_LCs,"%d\t",count_LC);
       //write period of LC:
       fprintf(fh_LCs,"%d\t",SIZE_OF_PERIOD);
         for(k=0;k<NUM_NODES;k++){ 
            //save log2(gene expression):
            fprintf(fh_LCs,"%10.6f\t",log(LC_exp_arr[j][k])/log(2));
         }
         //new line to separate the expressions from 
         //those of the next time step: 
         fprintf(fh_LCs,"%s","\n");
    } 
    //new line after writing the whole LC
    //this separates expressions between limit cycles:
    fprintf(fh_LCs,"%s","\n");
    return;
}

/*-----------------------------------------------------------------------*/
void cal_fX(int NUM_NODES,int NUM_EDGES,\
            double EULER_STEP_SIZE,\
            double TRANS_RATE_FACTOR,\
            const double *MPR_arrv,
            const double *DNR_arrv,\
            const int *node_type_arrv,\
            const int *edge_source_arrv,\
            const int *edge_target_arrv,\
            const int *edge_type_arrv,\
            const double *TSH_arrv,\
            const int *HCO_arrv,\
            const double *FCH_arrv,\
            double const *curr_exp_arr,\
            double *fX_arr)
{
    //double fX_arr[NUM_NODES]; //fX_arr saves fX values in each Euler step
    double fX2_arr[NUM_NODES]; //fX2_arr saves fX values for degradation part 
    int i;

    //fX=Gx:
    //fX2=kX*X:
    for (i=0;i<NUM_NODES;++i) {
        fX_arr[i]=MPR_arrv[i]; 
        fX2_arr[i]=DNR_arrv[i]*curr_exp_arr[i]; 
    } 
    //update fX with regulations:
    for (i=0;i<NUM_EDGES;i++){
        if (edge_type_arrv[i]==1 || edge_type_arrv[i]==5) {
           fX_arr[edge_target_arrv[i]] *=\
	          eval_shiftedHill_fn(curr_exp_arr[edge_source_arrv[i]],\
                             	 TSH_arrv[i],HCO_arrv[i],\
                           		 FCH_arrv[i])/FCH_arrv[i]; 
        }
        else if (edge_type_arrv[i]==2 || edge_type_arrv[i]==6) {
           fX_arr[edge_target_arrv[i]] *=\
                  eval_shiftedHill_fn(curr_exp_arr[edge_source_arrv[i]],\
                           		 TSH_arrv[i],HCO_arrv[i],\
 				         FCH_arrv[i]);
        }
        else if (edge_type_arrv[i]==3 || edge_type_arrv[i]==4) {
           fX2_arr[edge_target_arrv[i]] *=\
                  eval_shiftedHill_fn(curr_exp_arr[edge_source_arrv[i]],\
                           		 TSH_arrv[i],HCO_arrv[i],\
 				         FCH_arrv[i]); 
        }
    }
    //adjust fX by kX*X:
    for (i=0;i<NUM_NODES;++i) {
        fX_arr[i]-=fX2_arr[i];
        if (node_type_arrv[i]==2){
           fX_arr[i]*=TRANS_RATE_FACTOR;
        } 
    }
    return;
}

/*-----------------------------------------------------------------------*/
void estimate_stable_expression(int NUM_NODES,int NUM_EDGES,\
                                int ITER_FOR_ODE,int TOTAL_EULER_STEPS,\
                                double EULER_STEP_SIZE,\
                                long double CONVERGENCE_PROXIMITY,\
                                double TRANS_RATE_FACTOR,\
                                const double *MPR_arrv,\
                                const double *DNR_arrv,\
                                const int *node_type_arrv,
                    		        const int *edge_source_arrv,\
                    		        const int *edge_target_arrv,\
                    		        const int *edge_type_arrv,\
                                const double *TSH_arrv,\
                    		        const int *HCO_arrv,\
                    		        const double *FCH_arrv,\
                                const double *IC_arr, double *exp_arr,\
                                double *fX_arr)
{
    //CONSTANTS:
    const int ITER_FOR_RELAXATION=sim_config.ITER_FOR_RELAXATION;

    double curr_exp_arr[NUM_NODES];
    double next_exp_arr[NUM_NODES];
    double test_delta=0.0;
    int iter_count=0;
    int i=0;

    double fX_norm; 
    double fX_norm_now;

    //copy ICs to a local variable:
    for (i=0;i<NUM_NODES;++i) {
        curr_exp_arr[i]=IC_arr[i];
    }

    while(iter_count<ITER_FOR_ODE)
    {
        cal_euler_approximation(NUM_NODES,NUM_EDGES,TOTAL_EULER_STEPS,\
                                EULER_STEP_SIZE,TRANS_RATE_FACTOR,\
                                MPR_arrv,DNR_arrv,node_type_arrv,\
                                edge_source_arrv,edge_target_arrv,\
                                edge_type_arrv,TSH_arrv,HCO_arrv,FCH_arrv,\
    			                    curr_exp_arr,next_exp_arr,fX_arr);

        test_delta=sum_delta(curr_exp_arr,next_exp_arr,NUM_NODES);
        
        //check for convergence to a state:
        //if the simulation converges to a state, then break out of the loop:
        if (test_delta<=CONVERGENCE_PROXIMITY){
            break;
        }
        fX_norm_now=cal_norm(fX_arr,NUM_NODES);
        //check for convergence to a limit cycle:
        //after ITER_RELAXATION times of iteration, check whether limit
        //cycle situation arises. If it does, break outf of the loop:
        if (iter_count>ITER_FOR_RELAXATION) 
        {
            if(fX_norm_now>fX_norm) break;
        }
        fX_norm=fX_norm_now;
       
        //update curr_exp_arr:
        for (i=0;i<NUM_NODES;++i) {
            curr_exp_arr[i]=next_exp_arr[i]; 
        }
        iter_count+=1;
    } 
    //copy the expression to exp_arr for returning:
    for (i=0;i<NUM_NODES;i++){
        exp_arr[i]=next_exp_arr[i];
    }
    //for (int j=0;j<NUM_NODES;j++) printf("%f\t",fX_arr[j]); 
    //printf("\n"); 
    return;
}

/*-----------------------------------------------------------------------*/
void cal_euler_approximation(int NUM_NODES,int NUM_EDGES,\
                             int TOTAL_EULER_STEPS,double EULER_STEP_SIZE,\
                             double TRANS_RATE_FACTOR,\
                             const double *MPR_arrv,const double *DNR_arrv,\
                             const int *node_type_arrv,\
                             const int *edge_source_arrv,\
                             const int *edge_target_arrv,\
                             const int *edge_type_arrv,\
                             const double *TSH_arrv,\
                             const int *HCO_arrv,\
                             const double *FCH_arrv,\
                             double const *curr_exp_arrv,\
                             double *next_exp_arr,double *fX_arr)
{

   /* 
     Given the current value of an n dimensional point, this function 
     calculates the final value of the point after TOTAL_EULER_STEPS, 
     by using the Euler approximation method.
    */
    //double fX_arr[NUM_NODES]; //fX_arr saves fX values in each Euler step
    double fX2_arr[NUM_NODES]; //fX2_arr saves fX values for degradation part 
    double curr_exp_arr[NUM_NODES]; //start expression (n dimensional point)
    double hill_impact=0.0;
    int fX_POINTS=(int) (TOTAL_EULER_STEPS/100);
    int i;
    //EULER_STEP_SIZE*=0.1;
//    const double FAST_EULER_STEP_SIZE=EULER_STEP_SIZE*TRANS_RATE_FACTOR; 
    double fX_norm=0.0; 

    int step_count=0; 
 
    //copy start expressions to a local variable:
    for (i=0;i<NUM_NODES;++i) {
        curr_exp_arr[i]=curr_exp_arrv[i]; 
    }
    //fX_norm=0.0;
    while(step_count<TOTAL_EULER_STEPS)
    {
        //calculate the slope/rate at the current point: 
        cal_fX(NUM_NODES,NUM_EDGES,EULER_STEP_SIZE,\
               TRANS_RATE_FACTOR,\
               MPR_arrv,DNR_arrv,\
               node_type_arrv,edge_source_arrv,\
               edge_target_arrv,edge_type_arrv,\
               TSH_arrv,HCO_arrv,FCH_arrv,\
               curr_exp_arr,fX_arr);
        //for (int j=0;j<NUM_NODES;j++) printf("%f\t",fX_arr[j]); 
        //printf("\n");  
        //exit(0);
        //calculate next expressions: y=y+hF
        for (i=0;i<NUM_NODES;++i) {
             next_exp_arr[i]=curr_exp_arr[i]+fX_arr[i]*EULER_STEP_SIZE;
        }
        //update curr_exp_arr:
        //prevent curr_exp_arr value from getting -ve value:
        //set it to zero, if negative exp value is encountered:
        for (i=0;i<NUM_NODES;++i) {
            //curr_exp_arr[i]=next_exp_arr[i];
            curr_exp_arr[i]=next_exp_arr[i]>=0?next_exp_arr[i]:0; 
        }
        step_count+=1;
        
        /*
	if ((step_count%fX_POINTS)==0)
        {
            fX_norm+=cal_norm(fX_arr,NUM_NODES);
        }
        */
    }
    //printf("%f\n",fX_norm);
    return;
}

/* ---- ODE simulation  ----- */
void cal_ode(int NUM_NODES,int NUM_EDGES,\
			    int TOTAL_EULER_STEPS,double EULER_STEP_SIZE,\
             double TRANS_RATE_FACTOR,\
             const double *MPR_arrv,const double *DNR_arrv,\
             const int *node_type_arrv,\
             const int *edge_source_arrv,\
             const int *edge_target_arrv,\
             const int *edge_type_arrv,\
             const double *TSH_arrv,\
             const int *HCO_arrv,\
             const double *FCH_arrv,\
             double const *curr_exp_arrv)
{

    double fX_arr[NUM_NODES]; //fX_arr saves fX values in each Euler step
    //double fX2_arr[NUM_NODES]; //fX2_arr saves fX values for degradation part 
    double curr_exp_arr[NUM_NODES];
    double next_exp_arr[NUM_NODES];
    double hill_impact=0.0; 
    int fX_POINTS=(int) (TOTAL_EULER_STEPS/100);
    int i;
    //EULER_STEP_SIZE*=0.1;
    //const double FAST_EULER_STEP_SIZE=EULER_STEP_SIZE*TRANS_RATE_FACTOR; 
    double fX_norm; 
    

    int step_count=0; 
    FILE *fh_out=NULL; 
    char fname[100]="out.txt";

    fh_out=fopen(fname,"w");
    if (fh_out==NULL) { 
        printf("error opening file\n"); 
        exit(0);
    } 
    //copy start expressions to a local variable:
    for (i=0;i<NUM_NODES;++i) {
        curr_exp_arr[i]=curr_exp_arrv[i]; 
    }
    fX_norm=0.0;
    while(step_count<TOTAL_EULER_STEPS)
    {
        cal_fX(NUM_NODES,NUM_EDGES,EULER_STEP_SIZE,\
               TRANS_RATE_FACTOR,\
               MPR_arrv,DNR_arrv,\
               node_type_arrv,edge_source_arrv,\
               edge_target_arrv,edge_type_arrv,\
               TSH_arrv,HCO_arrv,FCH_arrv,\
               curr_exp_arr,fX_arr);
        //calculate next expressions:
        for (i=0;i<NUM_NODES;++i) {
             next_exp_arr[i]=curr_exp_arr[i]+fX_arr[i]*EULER_STEP_SIZE;
        }
        //update curr_exp_arr:
        //prevent curr_exp_arr value from getting -ve value:
        //set it to zero, if negative exp value is encountered:
        step_count+=1;
	fprintf(fh_out,"%d\t",step_count);
        for (i=0;i<NUM_NODES;++i) {
            //curr_exp_arr[i]=next_exp_arr[i];
            curr_exp_arr[i]=next_exp_arr[i]>=0?next_exp_arr[i]:0; 
	    fprintf(fh_out,"%f\t", curr_exp_arr[i]);
        }
	fprintf(fh_out,"\n");
    }
    fclose(fh_out);
    return;
}

/*-----------------------------------------------------------------------*/
void cal_EXPrange(int NUM_NODES,int NUM_EDGES,const double *MPR_arrv,\
             const double *DNR_arrv,const int *edge_source_arrv,\
             const int *edge_target_arrv,const int *edge_type_arrv,\
             const double *FCH_arrv,double *minEXP_arr, double *maxEXP_arr)
/*------------------------------------------------------------------
 It calculates gene expression range to be used in IC estimation 
considering the edge type and FCH.

It calculates the allowable minimum and maximum expression for each 
node, based on the following rules:
   (1) Initially, set the minimum and maximum expressions of each 
       node based on MPR and DNR:
       minEXP(X) <- MPR(X)/DNR(X)
       maxEXP(X) <- minEXP(X)

   (2) Then, update these values based on regulator type
       for each regulator Y (edge Y->X):
         if edge type 1 or 5: 
            minEXP(X) <- minEXP(X)/FCH(Y->X)
         if edge type 2 or 6: 
            minEXP(X) <- minEXP(X)*FCH(Y->X)
         if edge type 4: 
            minEXP(X) <- FCH(Y->X)
         if edge type 3: 
            minEXP(X) <- FCH(Y->X)
--------------------------------------------------------------------*/
{
    int i;
    
    //set minEXP_arr and maxEXP_arr based on MPR and DNR:
    for (i=0;i<NUM_NODES;++i) {
        minEXP_arr[i]=MPR_arrv[i]/DNR_arrv[i]; 
        maxEXP_arr[i]=minEXP_arr[i];
    }

    //update minEXP_arr based on type of regulators:
    for (i=0;i<NUM_EDGES;i++){
        //if (edge_type_arrv[i]==REG_EXCITATORY) {
        if (edge_type_arrv[i]==1 || edge_type_arrv[i]==5) {
           minEXP_arr[edge_target_arrv[i]] /= FCH_arrv[i];
        }
        //else if (edge_type_arrv[i]==REG_INHIBITORY) {
        else if (edge_type_arrv[i]==2 || edge_type_arrv[i]==6) {
           minEXP_arr[edge_target_arrv[i]] *= FCH_arrv[i];
        }
        else if (edge_type_arrv[i]==4) {
           minEXP_arr[edge_target_arrv[i]] /= FCH_arrv[i];
        }
        else if (edge_type_arrv[i]==3) {
           maxEXP_arr[edge_target_arrv[i]] /= FCH_arrv[i];
        }
    }
    return;
}

/*-----------------------------------------------------------------------*/
void set_ICs(int NUM_NODES, const double *minEXP_arr, \
             const double *maxEXP_arr, double *IC_arr)
{
    //double maxEXP_arr[NUM_NODES],minEXP_arr[NUM_NODES];
    int i;

    //generate random ICs within a range:
    for (i=0;i<NUM_NODES;++i) {
        IC_arr[i]=exp2(randu(log2(minEXP_arr[i]),log2(maxEXP_arr[i])));
    }
    return;
}

/*-----------------------------------------------------------------------*/
void set_ICs_by_sstate(int NUM_NODES, const double *std_st_exp_arr, \
                       double *IC_arr)
{
    int i;

    //set steady state expressions as ICs:
    for (i=0;i<NUM_NODES;++i) {
        IC_arr[i] = std_st_exp_arr[i];
    }
    return;
}

/*-----------------------------------------------------------------------*/
double eval_shiftedHill_fn (double x, double x0, double nx, double lamda)
{
  return (lamda+(1.0-lamda)*(1.0/(1.0+pow((x/x0),nx))));
}

/*-----------------------------------------------------------------------*/
double sum_delta (double *curr_exp, double *next_exp, int NUM_NODES)
{
    int i = 0;
    double ssq = 0.0;
    
    for (i=0;i<NUM_NODES;i++){
        ssq+=pow(curr_exp[i]-next_exp[i],2);
    }
    return ssq;
}

/*-----------------------------------------------------------------------*/
double cal_norm (double *curr_exp, int NUM_NODES)
{
    int i = 0;
    double ssq = 0.0;
    
    for (i=0;i<NUM_NODES;i++){
        ssq+=pow(curr_exp[i],2);
    }
    return ssq;
}

/*-----------------------------------------------------------------------*/
bool is_element(int key, const int *arr, int size) 
{ 
    int i;
    for (i=0;i<size;i++) 
    {
        if (key== arr[i]) 
            return true; 
    }
    return false; 
}

/*-----------------------------------------------------------------------*/
double **allocate_LCmemory(int LC_SIZE, int NUM_NODES)
{
    //allocates memory for limit cycle:
    double **EXP_arr; 
    int i,j; 
    EXP_arr=(double **) calloc(LC_SIZE,sizeof(double));
    for (i=0; i<LC_SIZE;i++){ 
       EXP_arr[i]=(double *) calloc(NUM_NODES,sizeof(double));
    }

    for (i=0; i<LC_SIZE;i++){ 
        for(j=0;j<NUM_NODES;j++){
           EXP_arr[i][j]=0.0;
        }
    }
    return EXP_arr;
}

/*-----------------------------------------------------------------------*/
void free_LCmemory(double **EXP_arr, int LC_SIZE, int NUM_NODES)
{
    //free the allocated memory:
    int i;
    //first free allocated memory for gene expression for each node:
    for (i=0; i<LC_SIZE;i++){
       free(EXP_arr[i]);
    }
    //second, free memory allocated for holding the memory address:
    free(EXP_arr);
}

/*-----------------------------------------------------------------------*/
void read_config(char *WORK_DIR, char* fname_cfg)
{ 
    //reads the deafult values from the config file 

    char fname[300]="\0";
    strcat(fname,WORK_DIR);
    strcat(fname,"/");
    strcat(fname,fname_cfg);

    FILE *fh_config;
    fh_config=fopen(fname,"r");

    char* line=malloc(LINE_SIZE); 
    char delim[5];
    char *token; 
    strcpy(delim,CONFIG_FILE_DELIM);
    //printf("%s\n",CONFIG_FILE_DELIM);
    //printf("within read config\n");

    while(fgets(line,LINE_SIZE,fh_config)!=NULL) {
         token=strtok(line,delim);
         if(strcmp(token,"NUM_RANDOM_ICS")==0){
               token=strtok(NULL,"\n"); 
               sim_config.NUM_RANDOM_ICS=strtol(token,NULL,10);
         }
         else if(strcmp(token,"CONVERGENCE_PROXIMITY")==0){
               token=strtok(NULL,"\n"); 
               sim_config.CONVERGENCE_PROXIMITY=strtod(token,NULL);
         }
         else if(strcmp(token,"SAMEPOINT_PROXIMITY")==0){
               token=strtok(NULL,"\n"); 
               sim_config.SAMEPOINT_PROXIMITY=strtod(token,NULL);
         }
         else if(strcmp(token,"ITER_FOR_ODE")==0){
               token=strtok(NULL,"\n"); 
               sim_config.ITER_FOR_ODE=strtol(token,NULL,10);
         }
         else if(strcmp(token,"ITER_FOR_RELAXATION")==0){
               token=strtok(NULL,"\n"); 
               sim_config.ITER_FOR_RELAXATION=strtol(token,NULL,10);
         }
         else if(strcmp(token,"ITER_FOR_LIMIT_CYCLE")==0){
               token=strtok(NULL,"\n"); 
               sim_config.ITER_FOR_LIMIT_CYCLE=strtol(token,NULL,10);
         }
         else if(strcmp(token,"EULER_SIM_TIME")==0){
               token=strtok(NULL,"\n"); 
               sim_config.EULER_SIM_TIME=strtod(token,NULL);
         }
         else if(strcmp(token,"EULER_SIM_TIME_LAST_ANN_STEP")==0){
               token=strtok(NULL,"\n"); 
               sim_config.EULER_SIM_TIME_LAST_ANN_STEP=strtod(token,NULL);
         }
         else if(strcmp(token,"STARTING_NOISE_ANN")==0){
               token=strtok(NULL,"\n"); 
               sim_config.STARTING_NOISE_ANN=strtod(token,NULL);
         }
         else if(strcmp(token,"STARTING_NOISE_CONSTANT")==0){
               token=strtok(NULL,"\n"); 
               sim_config.STARTING_NOISE_CONSTANT=strtod(token,NULL);
         }
         else if(strcmp(token,"NOISE_SCALING_FACTOR_ANN")==0){
               token=strtok(NULL,"\n"); 
               sim_config.NOISE_SCALING_FACTOR_ANN=strtod(token,NULL);
         }
         else if(strcmp(token,"LIMIT_CYCLE_SIM_TIME")==0){
               token=strtok(NULL,"\n"); 
               sim_config.LIMIT_CYCLE_SIM_TIME=strtod(token,NULL);
         }
         else if(strcmp(token,"EULER_SIM_STEP_SIZE")==0){
               token=strtok(NULL,"\n"); 
               sim_config.EULER_SIM_STEP_SIZE=strtod(token,NULL);
         }
         else if(strcmp(token,"LIMIT_CYCLE_SIM_STEP_SIZE")==0){
               token=strtok(NULL,"\n"); 
               sim_config.LIMIT_CYCLE_SIM_STEP_SIZE=strtod(token,NULL);
         }
         else if(strcmp(token,"MAX_STABLE_STATES")==0){
               token=strtok(NULL,"\n"); 
               sim_config.MAX_STABLE_STATES=strtol(token,NULL,10);
         }
         else if(strcmp(token,"MAX_LIMIT_CYCLES")==0){
               token=strtok(NULL,"\n"); 
               sim_config.MAX_LIMIT_CYCLES=strtol(token,NULL,10);
         }
         else if(strcmp(token,"MAX_ALLOWED_PERIODS")==0){
               token=strtok(NULL,"\n"); 
               sim_config.MAX_ALLOWED_PERIODS=strtol(token,NULL,10);
         }
         else if(strcmp(token,"NO_OF_SAMPLED_PERIODS")==0){
               token=strtok(NULL,"\n"); 
               sim_config.NO_OF_SAMPLED_PERIODS=strtol(token,NULL,10);
         }
         else if(strcmp(token,"ALLOWED_ERROR_IN_PERIODS")==0){
               token=strtok(NULL,"\n"); 
               sim_config.ALLOWED_ERROR_IN_PERIODS=strtol(token,NULL,10);
         }
    }
    fclose(fh_config);
    free(line);
    return;
} 

/*-----------------------------------------------------------------------*/
void print_config()
{ 
    printf("NUM_RANDOM_ICS: %d\n",sim_config.NUM_RANDOM_ICS);
    printf("CONVERGENCE_PROXIMITY: %LE\n",sim_config.CONVERGENCE_PROXIMITY);
    printf("SAMEPOINT_PROXIMITY: %f\n",sim_config.SAMEPOINT_PROXIMITY);
    printf("ITER_FOR_ODE: %d\n",sim_config.ITER_FOR_ODE);
    printf("ITER_FOR_RELAXATION: %d\n",sim_config.ITER_FOR_RELAXATION);
    printf("ITER_FOR_LIMIT_CYCLE: %d\n",sim_config.ITER_FOR_LIMIT_CYCLE);
    printf("EULER_SIM_TIME: %f\n",sim_config.EULER_SIM_TIME);
    printf("LIMIT_CYCLE_SIM_TIME: %f\n",sim_config.LIMIT_CYCLE_SIM_TIME);
    printf("EULER_SIM_STEP_SIZE: %f\n",sim_config.EULER_SIM_STEP_SIZE);
    printf("LIMIT_CYCLE_SIM_STEP_SIZE: %f\n",sim_config.LIMIT_CYCLE_SIM_STEP_SIZE);
    printf("MAX_STABLE_STATES: %d\n",sim_config.MAX_STABLE_STATES);
    printf("MAX_LIMIT_CYCLES: %d\n",sim_config.MAX_LIMIT_CYCLES);
    printf("MAX_ALLOWED_PERIODS: %d\n",sim_config.MAX_ALLOWED_PERIODS);
    printf("NO_OF_SAMPLED_PERIODS: %d\n",sim_config.NO_OF_SAMPLED_PERIODS);
    printf("ALLOWED_ERROR_IN_PERIODS: %d\n",sim_config.ALLOWED_ERROR_IN_PERIODS);
    return;
}
